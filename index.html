<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Austin.RB - Ruby to Elixir</title>

		<meta name="description" content="Ruby to Elixir at Austin.RB">
		<meta name="author" content="Luke Imhoff">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Austin.RB</h1>
                    <h2>Ruby to Elixir</h2>
                    <p>2015-08-03</p>
                    <p>Luke Imhoff</p>
                    <table>
                        <tbody>
                        <tr>
                            <th>
                                <svg
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px" viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
                                            <g>
                                                <path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                                <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                                <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                                <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                            </g>
                                        </svg>
                            </th>
                            <td>luke_imhoff@rapid7.com</td>
                            <td>Kronic.Deth@gmail.com</td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="github-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                                        </svg>
                            </th>
                            <td>
                                <a href="https://github.com/limhoff-r7" target="_blank">@limhoff-r7</a>
                            </td>
                            <td>
                                <a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
                            </th>
                            <td></td>
                            <td>
                                <a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <aside class="notes">
                        I am a Senior Software Engineer for Metasploit Applications at Rapid7
                    </aside>
                </section>
                <section>
                    <h1>Outline</h1>
                    <ol>
                        <li>
                            <a href="#/overview">Overview</a>
                        </li>
                        <li>
                            <a href="#/installation">Installation</a>
                        </li>
                        <li>
                            <a href="#/interactive">Interactive</a>
                        </li>
                        <li>
                            <a href="#/types">Types</a>
                        </li>
                        <li>
                            <a href="#/control-flow">Control Flow</a>
                        </li>
                        <li>
                            <a href="#/pattern-matching">Pattern Matching</a>
                        </li>
                        <li>
                            <a href="#/project">Project</a>
                        </li>
                        <li>
                            <a href="#/code">Code</a>
                        </li>
                        <li>
                            <a href="#/testing">Testing</a>
                        </li>
                    </ol>
                </section>
                <section class="stack">
                    <section id="overview">
                        <h1>Overview</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th rowspan="4">Paradigms</th>
                                <th>Imperative</th>
                                <td>&#10003;</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Concurrent</th>
                                <td></td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Functional</th>
                                <td>&#10003;</td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Object-Oriented</th>
                                <td>&#10003;</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th rowspan="3">Typing</th>
                                <th>Dynamic</th>
                                <td>&#10003;</td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Duck</th>
                                <td>&#10003;</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Strong</th>
                                <td></td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th colspan="2">Mutability</th>
                                <td>Mutable</td>
                                <td>Immutable</td>
                            </tr>
                            <tr>
                                <th rowspan="2">Concurrency</th>
                                <th>CPU-bound</th>
                                <td>OS Processes</td>
                                <td>VM Processes</td>
                            </tr>
                            <tr>
                                <th>IO-bound</th>
                                <td>Threads, Fibers</td>
                                <td>VM Processes</td>
                            </tr>
                            <tr>
                                <th colspan="2">Metaprogramming</th>
                                <td>Runtime, Class Methods</td>
                                <td>Compilation, Macros</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Elixir is a functional language that is dynamically typed using immutable
                                data that is highly concurrent.
                            </p>
                            <p>
                                MRI Ruby's go-to concurrency approach of forking a process has too high of a overhead and is
                                only tolerable on system with Copy-On-Write (COW) fork, which excludes Windows.  Threading
                                and fibers in the MRI cannot get around the GIL and so only help with IO-bound code.
                            </p>
                            <p>
                                On the other hand, Elixir uses the Erlang VM, which thanks to the immutable data, can run
                                isolated processes inside the VM so fast and so cheaply that my laptop can run 1 million
                                processes in 11 seconds with processes distributed across all 4 cores.
                            </p>
                            <p>
                                Just as you learned imperative programming over mathematical thinking, you can retrain
                                to think in functional languages and even switch back and forth.  I currently switch
                                between Java, Ruby, and Elixir.  With only a few hiccups on namespace syntax and
                                string quoting.  If you're used to using <code>map</code> or <code>select</code> from
                                <code>Enumerable</code> in Ruby, you are already using functional programming.  If you
                                ever used class methods in Ruby that didn't write to class or instance variable, you're
                                already using functional programming.
                            </p>
                            <p>
                                Learning functional programming will also prepare you for the future.  If you watch
                                conference talks in other languages, such as Javascript or C++, languages are moving to
                                have more and more functional features as the programming community adapts to the
                                many-cores future.  They have figured out that locks, threads, and shared mutable
                                state is too error prone.
                            </p>
                            <p>
                                Moore's law increasing processor speed stopped 10 years ago. If you want to take
                                advantage of Moore's law now and in the future you need to write concurrent programs now
                                that can be parallelized across the additional cores of the future automatically.
                            </p>
                            <p>
                                Switching from imperative, mutable, object-oriented Ruby to functional, immutable,
                                concurrent Elixir may be intimidating, but I'll show you how easy it is to translate your
                                Ruby skills to Elixir to quickly get started learning Elixir on your own.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="installation">
                        <h1>Installation</h1>
                        <ul>
                            <li><a href="#/installation-osx">OSX</a></li>
                            <li><a href="#/installation-windows">Windows</a></li>
                            <li><a href="#/installation-linux">Linux</a></li>
                        </ul>
                    </section>
                    <section id="installation-osx">
                        <h1>OSX</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Homebrew</td>
                                <td>
                                    <code>brew install ruby</code>
                                </td>
                                <td>
                                    <code>brew install elixir</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Version Manager</td>
                                <td>
                                    <code>rvm install VERSION</code>
                                </td>
                                <td>
                                    <code>kiex install VERSION</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Ruby and Elixir both have homebrew packages and version managers.
                            </p>
                            <p>
                                If you use <code>kiex</code>, you'll need to install Erlang separately using either
                                <code>kerl</code>, spelled K-E-R-L, or homebrew
                            </p>
                        </aside>
                    </section>
                    <section id="installation-windows">
                        <h1>Windows</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Installer</td>
                                <td>
                                    <a href="http://rubyinstaller.org/">
                                        <code>rubyinstaller.exe</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://s3.amazonaws.com/s3.hex.pm/elixir-websetup.exe">
                                        <code>elixir-websetup.exe</code>
                                    </a>
                                </td>
                            </tr>
                            <tr>
                                <td>Chocolatey</td>
                                <td>
                                    <code>cinst ruby</code>
                                </td>
                                <td>
                                    <code>cinst elixir</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Both Ruby and Elixir have installers for installing the languages as a Program in Windows.
                            </p>
                            <p>
                                You can alternatively use the Chocolatey (or NuGET) package manager for Windows.
                            </p>
                        </aside>
                    </section>
                    <section id="installion-linux">
                        <h1>Linux</h1>
                        <p>Use your package manager</p>
                    </section>
                </section>
                <section class="stack">
                    <section id="interactive">
                        <h1>Interactive</h1>
                        <ul>
                            <li>
                                <a href="#/interactive-starting">Starting</a>
                            </li>
                            <li>
                                <a href="#/interactive-breaking">Breaking</a>
                            </li>
                            <li>
                                <a href="#/interactive-exiting">Exiting</a>
                            </li>
                        </ul>
                    </section>
                    <section id="interactive-starting">
                        <h1>
                            Starting Interactive
                        </h1>
                        <table>
                            <thead>
                                <tr>
                                    <th>Ruby</th>
                                    <th>Elixir</th>
                                </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>irb</code>
                                </td>
                                <td>
                                    <code>iex</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="interactive-breaking">
                        <h1>Breaking the current command</h1>
                        <table>
                            <thread>
                                <tr>
                                    <th>Ruby</th>
                                    <th>Elixir</th>
                                </tr>
                            </thread>
                            <tbody>
                            <tr>
                                <th>CTRL+C</th>
                                <th><code>#iex:break</code> on line by itself</th>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            If you make a typing mistake in <code>irb</code>, you're probably used to hitting CTRL+C,
                            but if you do that in <code>iex</code> you'll get a prompt asking whether to abort, continue,
                            kill, and some other options.  To mimic the behavior of CTRL+C from <code>irb</code>, type
                            the comment <code>iex</code> colon <code>break</code> on a line by itself.
                        </aside>
                    </section>
                    <section id="interactive-exiting">
                        <table>
                            <thread>
                                <tr>
                                    <th>Ruby</th>
                                    <th>Elixir</th>
                                </tr>
                            </thread>
                            <tbody>
                            <tr>
                                <th><code>exit</code></th>
                                <th>CTRL+C CTRL+C</th>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            A single CTRL+C in <code>iex</code> will bring up the break handler, which allows you to
                            inspect the running VM and kill individual processes.
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="types">
                        <h1>Types</h1>
                        <ul>
                            <li>
                                <a href="#/types-numeric">Numeric</a>
                            </li>
                            <li>
                                <a href="#/types-constant">Constant</a>
                            </li>
                            <li>
                                <a href="#/types-boolean">Boolean</a>
                            </li>
                            <li>
                                <a href="#/types-string">String</a>
                            </li>
                            <li>
                                <a href="#/types-regular-expression">Regular Expression</a>
                            </li>
                            <li>
                                <a href="#/types-anonymous-function">Anonymous Function</a>
                            </li>
                            <li>
                                <a href="#/types-collection">Collection</a>
                            </li>
                        </ul>
                    </section>
                    <section id="types-numeric">
                        <h1>Numeric Types</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <th>Example</th>
                                <th>Name</th>
                                <th>Example</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Integer</td>
                                <td>
                                    <code>9</code>, <code>0b1</code>, <code>0o7</code>, <code>0xF</code>
                                </td>
                                <td>Integer</td>
                                <td>
                                    <code>9</code>, <code>0b1</code>, <code>0o7</code>, <code>0xF</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Float</td>
                                <td>
                                    <code>1.2</code>, <code>3e+0</code>
                                </td>
                                <td>float</td>
                                <td>
                                    <code>1.2</code>, <code>3e+0</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Integer formats are the same for Ruby and Elixir.  They both support, decimal, binary,
                                octal, and hexadecimal.  Underscore (_) can be used to separate digit groups.
                            </p>
                            <p>
                                Float formats are the same for Ruby and Elixir.  They both support 'e' notation.
                            </p>
                        </aside>
                    </section>
                    <section id="types-constant">
                        <h1>Constant Types</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <th>Example</th>
                                <th>Name</th>
                                <th>Example</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Symbol</td>
                                <td>
                                    <code>:symbol</code>, <code>:"symbol"</code>, <code>:'symbol'</code>
                                </td>
                                <td>Atom</td>
                                <td>
                                    <code>:atom</code>, <code>:"atom"</code>, <code>:'atom'</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Class/Module name</td>
                                <td>
                                    <code>MyClass</code>, <code>MyNamespace::MyModule</code>
                                </td>
                                <td>Alias</td>
                                <td>
                                    <code>MyModule</code>, <code>MyNamespace.MyModule</code>, <code>:erlang_module</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Constant</td>
                                <td>
                                    <code>MY_CONSTANT</code>
                                </td>
                                <td>Module Attribute</td>
                                <td>
                                    <code>@my_attribute</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Symbol in Ruby just becomes the word Atom in Elixir.
                            </p>
                            <p>
                                Class/Module names and Aliases both share camel-casing, but namespaces in Class/Module
                                names are separated with colon-colon (::), while Alias names are separated with dot (.).
                                Additionally, Erlang modules are just atoms.  Aliases are called Aliases because they
                                are actually syntactic sugar with an atom starting with Elixir dot (Elixir.)
                            </p>
                            <p>
                                Your brain may read module attributes as being like class instance variables in Ruby
                                since they both start with at (@) and look like a variable, but module attributes don't
                                get assigned to with equals (=), instead they are referenced before the value to put into
                                the module attribute.  This is because module attributes can be configured to either
                                reset their value or accumulate all values passed to them.  This allows for some nice
                                features, which I'll get to later.
                            </p>
                        </aside>
                    </section>
                    <section id="types-boolean">
                        <h1>Boolean Types</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>false</code>
                                </td>
                                <td>
                                    <code>false</code>, <code>:false</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>nil</code>
                                </td>
                                <td>
                                    <code>nil</code>, <code>:nil</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>true</code>
                                </td>
                                <td>
                                    <code>true</code>, <code>:true</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                In Elixir, false, nil, and true are all just syntactic sugar for the atoms of the same
                                name.
                            </p>
                            <p>
                                Both Ruby and Elixir has falsy logic, so both false and nil are false for boolean
                                operations.
                            </p>
                        </aside>
                    </section>
                    <section id="types-string">
                        <h1>Strings</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>Format</th>
                                <td>
                                    <code>"string"</code>
                                </td>
                                <td></td>
                                <td>
                                    <code>"string"</code>
                                </td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Interpolation</th>
                                <td>
                                    <code>"Hello #{:world}"</code>
                                </td>
                                <td>&#10003;</td>
                                <td>
                                    <code>"Hello #{:world}"</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Encoding</th>
                                <td>UTF-8</td>
                                <td></td>
                                <td>UTF-8</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Unicode Capitalization</th>
                                <td>
                                    <code>"José Valim".upcase # "JOSé VALIM"</code>
                                </td>
                                <td>&#10060;</td>
                                <td>
                                    <code>String.upcase "José Valim" # "JOSÉ VALIM"</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Unicode Graphemes Rendering</th>
                                <td>
                                    <code>"\u0065\u0301" # "é"</code>
                                </td>
                                <td>&#10003;</td>
                                <td>
                                    <code>"\x{0065}\x{0301}" # "é"</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Unicode Graphemes Length</th>
                                <td>
                                    <code>"\u0065\u0301".length # 2</code>
                                </td>
                                <td>&#10060;</td>
                                <td>
                                    <code>String.length "\x{0065}\x{0301}" # 1</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Ruby and Elixir support double quoted strings with interpolation encoded as UTF-8
                            </p>
                            <p>
                                Elixir excels at proper unicode handling compared to Ruby: Elixir properly capitalizes
                                e-acute (é) in José Valim while Ruby does not; Elixir properly handles the separate
                                e and acute accent being one grapheme while Ruby counts them as 2 characters for the
                                string length.
                            </p>
                            <p>
                                If you care about what the user actually sees, you want the number of graphemes in a
                                string, not the raw bytes, so Elixir's approach is correct.
                            </p>
                        </aside>
                    </section>
                    <section id="types-regular-expression">
                        <h1>Regular Expressions</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>Literals</th>
                                <td>
                                    <ul>
                                        <li>
                                            <code>/[A-Z]+/</code>
                                        </li>
                                        <li>
                                            <code>%r{[A-Z]+}</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>~r{[A-Z]+}</code>
                                        </li>
                                        <li>
                                            <code>~r[(.*)]</code>
                                        </li>
                                        <li>
                                            <code>~r&lt;[A-Z]+&gt;</code>
                                        </li>
                                        <li>
                                            <code>~r"[A-Z]+"</code>
                                        </li>
                                        <li>
                                            <code>~r/[A-Z]+/</code>
                                        </li>
                                        <li>
                                            <code>~r([A-Z]+)</code>
                                        </li>
                                        <li>
                                            <code>~r|[A-Z]+|</code>
                                        </li>
                                        <li>
                                            <code>~r'[A-Z]+'</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <th>Compile</th>
                                <td>
                                    <code>Regexp.new "string"</code>
                                </td>
                                <td>
                                    <code>Regexp.compile! "string"</code>
                                </td>
                            </tr>
                            <tr>
                                <th>Replace</th>
                                <td>
                                  <pre><code class="ruby">
'`spec` is a task for `rake`'.gsub(
  /`(.*?)`/,
  '&lt;code&gt;\1&lt;/code&gt;'
) # "&lt;code&gt;test&lt;/code&gt; is a task for &lt;code&gt;rake&lt;/code&gt;"
                                  </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir">
Regex.replace(
  ~r/`(.*?)`/,
  "`test` is a task for `mix`",
  "&lt;code&gt;\\1&lt;/code&gt;"
) # &lt;code&gt;test&lt;/code&gt; is a task for &lt;code&gt;mix&lt;/code&gt;"
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            Unlike Ruby, which only allows
                        </aside>
                    </section>
                    <section id="types-anonymous-function">
                        <h1>Anonymous Functions</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Declaration</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add = ->(a,b){ a + b }</code>
                                        </li>
                                        <li>
                                            <code>add = lambda { |a,b| a + b }</code>
                                        </li>
                                        <li>
                                            <code>add = proc { |a,b| a + b }</code>
                                        </li>
                                        <li>
                                            <code>add = Proc.new { |a, b| a + b}</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add = fn a, b -> a + b end</code>
                                        </li>
                                        <li>
                                            <code>add = fn (a, b) -> a + b end</code>
                                        </li>
                                        <li>
                                            <code>add = &(&1 + &2)</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Calling</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add.call(1,2)</code>
                                        </li>
                                        <li>
                                            <code>add.call 1, 2</code>
                                        </li>
                                        <li>
                                            <code>add.(1,2)</code>
                                        </li>
                                        <li>
                                            <code>add[1,2]</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add.(1,2)</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="types-collection">
                        <h1>Collections</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <th>Example</th>
                                <th>Name</th>
                                <th>Example</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Array</td>
                                <td>
                                    <code>[1,2,3]</code>
                                </td>
                                <td>Tuple</td>
                                <td>
                                    <code>[1,2,3]</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Hash</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>{a: 1, b: 2}</code>
                                        </li>
                                        <li>
                                            <code>{:a => 1, :b => 2}</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>Map</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>%{a: 1, b: 2}</code>
                                        </li>
                                        <li>
                                            <code>%{:a => 1, :b => 2}</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Set</td>
                                <td>
                                    <code>Set.new [1,2,3]</code>
                                </td>
                                <td>HashSet</td>
                                <td>
                                    <code>Enum.into [1,2,3], HashSet.new</code>
                                </td>
                            </tr>
                            <tr>
                                <td>&#10060;</td>
                                <td>&#10060;</td>
                                <td>Linked List</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>[1,2,3]</code>
                                        </li>
                                        <li>
                                            <code>[1 | [2 | [3 | []]]]</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>&#10060;</td>
                                <td>&#10060;</td>
                                <td>Keyword List</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>[a: 1, a: 2, b: 3]</code>
                                        </li>
                                        <li>
                                            <code>[{:a, 1}, {:a, 2}, {:b, 3}]</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Arrays and tuples are both contiguous in memory, but tuples are a fixed size while Ruby
                                Arrays are resizable.  Both allow lookup by index.
                            </p>
                            <p>
                                Both Set and HashSet are built on top of Hashes and don't support a built-in syntax
                                for initialization, and so here are populated using an Array and Linked List,
                                respectively.
                            </p>
                            <p>
                                Linked list can access the first (head) element or the rest (tail) elements quickly.
                                The Ruby standard library has linked list implementation.  The
                                <a href="https://github.com/hamstergem/hamster#list-api-documentation">
                                    hamster gem has <code>Hamster.list</code>
                                </a>.
                            </p>
                            <p>
                                A Keyword List allows multiple values for the same key and is implemented as a list
                                of 2-tuples.  So, not as efficient as a map, which is built is optimized, but useful
                                for named function arguments where an option can be repeated.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="control-flow">
                        <h1>Control Flow</h1>
                        <ul>
                            <li>
                                <a href="#/control-flow-boolean">Boolean</a>
                            </li>
                            <li>
                                <a href="#/control-flow-rescue">Rescue</a>
                            </li>
                            <li>
                                <a href="#/control-flow-catch">Catch</a>
                            </li>
                        </ul>
                    </section>
                    <section id="control-flow-boolean">
                        <h1>Boolean Control Flow</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby">
if false
  'This will never be seen'
else
  'This will'
end
                                    </code></pre>

                                </td>
                                <td>
                                    <pre><code class="elixir">
if false do
  "This will never be seen"
else
  "This will"
end
                                    </code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code class="ruby">
unless true
  'This will never be seen'
else
  'This will'
end
                                    </code></pre>

                                </td>
                                <td>
                                    <pre><code class="elixir">
unless true do
  "This will never be seen"
else
  "This will"
end
                                    </code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code class="ruby">
if one
  'one is true'
elsif two
  'two is true'
else
  'neither one nor two is true'
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir">
cond do
  one -> "one is true"
  two -> "two is true"
  true -> "neight one nor two is true"
end
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Take note that if and unless look the same in Ruby and Elixir, except that Elixir has a
                                'do' after the condition.  I'll explain why that is later.
                            </p>
                            <p>
                                Although Elixir has control flow, it is rare in idiomatic code to see if, unless or
                                cond.  It is much more likely to see pattern matching, which I'll cover next.
                            </p>
                        </aside>
                    </section>
                    <section id="control-flow-rescue">
                        <h1>Rescuing Exceptions</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                  <pre><code class="ruby" data-trim>
begin
  raise 'some error'
rescue RuntimeError => runtime_error
  puts runtime_error
rescue ArgumentError
  puts 'argument error occurred'
rescue => exception
  puts exception
rescue
  puts 'some exception'
else
  puts 'no exception'
ensure
  puts 'always runs'
end
                                  </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
try do
  raise "some error"
rescue
  x in [RuntimeError] ->
    IO.puts x.message
  ArgumentError ->
    IO.puts "argument error occurred"
  error ->
    IO.puts error
  _ ->
    IO.puts "some error"
else
  IO.puts "no error"
after
  puts "always run"
end
                                    </code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>begin</code>
                                </td>
                                <td>
                                    <code>try do</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue Klass => instance</code>
                                </td>
                                <td>
                                    <code>variable in [Alias] -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue Klass</code>
                                </td>
                                <td>
                                    <code>Alias -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue => exception</code>
                                </td>
                                <td>
                                    <code>error -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue</code>
                                </td>
                                <td>
                                    <code>_ -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>else</code>
                                </td>
                                <td>
                                    <code>else</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>ensure</code>
                                </td>
                                <td>
                                    <code>after</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>end</code>
                                </td>
                                <td>
                                    <code>end</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="control-flow-catch">
                        <h1>Catching Throws And Exits</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
answer = nil
catch (:done) do
  answer = 42
  throw :done
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
try do
  name = "Alice"
  throw("Hello", name)
  exit "I am exiting"
catch
  {greeting, name} ->
    IO.puts "#{greeting} to you, #{name}"
  :exit, _ -> "not really"
after
  IO.puts "Nothing thrown"
end
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Catch and throw are quite esoteric in ruby.  The only case I can think of them being used
                                in production is in parts of Rack.
                            </p>
                            <p>
                                In Elixir, catch and throw is only meant for use when you can't send a message up the
                                stack any other way.  However, Elixir's catch is far more flexible as the throw and
                                catch don't have to agree on single symbol to match on the way Ruby does.
                            </p>
                            <p>
                                Catch and exit are used all the time to monitor for VM processes exiting.  VM processes
                                monitoring each other is part of the resiliency features of Elixir, so it is very
                                important.  Most of the time, the standard library will handle the exit catching behind
                                the scenes.
                            </p>
                            <p>
                                You may have also noticed that rescuing exceptions and catching throws and exits all use
                                try.  It is actually possible to rescue exceptions and catch throws and exits in the
                                same try.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="pattern-matching">
                        <h1>Pattern Matching</h1>
                        <ul>
                            <li>
                                <a href="#/pattern-matching-variable-match">Assignment to Match</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-destructing-to-match">Destructuring to Match</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-argument-error-to-match">ArgumentError to Match</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-function-clauses">Function Clauses</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-case-statements">If Else to Case Statements</a>
                            </li>
                        </ul>
                    </section>
                    <section id="pattern-matching-variable-match">
                        <h1>Ruby Assignment to Elixir Matching</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Step</th>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>
                                    1
                                </th>
                                <th>
                                    <code>foo = 1</code>
                                </th>
                                <td>
                                    <code>foo</code> is <code>1</code>
                                </td>
                                <td>
                                    <code>foo</code> is <code>1</code>
                                </td>
                            </tr>
                            <tr>
                                <th>2</th>
                                <th>
                                    <code>1 = foo</code>
                                </th>
                                <td>
                                    SyntaxError
                                </td>
                                <td>
                                    <code>foo</code> is <code>1</code>
                                </td>
                            </tr>
                            <tr>
                                <th>3</th>
                                <th>
                                    <code>2 = foo</code>
                                </th>
                                <td>
                                    SyntaxError
                                </td>
                                <td>
                                    ** (MatchError) no match of right hand side value: 1
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                In Elixir, the equals sign (=) is the match operator.  The match operator should not be
                                thought of as assignment, but instead of trying to get the two sides of the equals sign
                                to match, which is why you can do foo equals 1 or 1 equals foo.
                            </p>
                            <p>
                                However, after already doing foo equals 1 (foo = 1) you can't do 2 equals foo because
                                the match operator will only rebind a variable if it is on the left-hand side.
                            </p>
                        </aside>
                    </section>
                    <section id="pattern-matching-destructing-to-match">
                        <h1>Destructuring to Match</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>a, b = [1, 2]</code>
                                </td>
                                <td>
                                    <code>a = 1</code><br/>
                                    <code>b = 2</code>

                                </td>
                                <td>
                                    <code>{a, b} = {1, 2}</code>
                                </td>
                                <td>
                                    <code>a = 1</code><br/>
                                    <code>b = 2</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>_, b = [1, 2]</code>
                                </td>
                                <td>
                                    <code>b = 2</code>
                                </td>
                                <td>
                                    <code>{_, b} = {1, 2}</code>
                                </td>
                                <td>
                                    <code>b = 2</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>a, b* = [1, 2, 3]</code>
                                </td>
                                <td>
                                    <code>a = 1</code><br/>
                                    <code>b = [2, 3]</code>
                                </td>
                                <td>
                                    <code>[a | b] = [1, 2, 3]</code>
                                </td>
                                <td>
                                    <code>a = 1</code><br/>
                                    <code>b = [2, 3]</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="pattern-matching-argument-error-to-match">
                        <h1>ArgumentError to Match</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code>
a, b = [nil, 2]
unless a == 1
  raise ArgumentError,
        "a should be 1"
end
                                    </code></pre>
                                </td>
                                <td>
                                    ArgumentError: a should be 1
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
{1, b} = {0, 2}
                                    </code></pre>
                                </td>
                                <td>
                                    ** (MatchError) no match of right hand side value: {nil, 2}
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code data-trim>
opening, closing = [:td, :th]
unless opening == closing
  raise ArgumentError,
        "opening and closing tag don't match"
end
                                    </code></pre>
                                </td>
                                <td>
                                    ArgumentError: opening and closing tag don't match
                                </td>
                                <td>
                                    <pre><code data-trim>
{tag, tag} = {:td, :th}
                                    </code></pre>
                                </td>
                                <td>
                                    * (MatchError) no match of right hand side value: {:td, :th}
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Instead of destructuring an argument and then checking its value as would be required in
                                Ruby, you can put the expected value into the pattern in Elixir and have Elixir check
                                the value for you.
                            </p>
                            <p>
                                The patterns automatically will enforce that when the same variable is used more than
                                once it must have the same value.  For example, you could check the closing and opening
                                tag match when parsing XML.
                            </p>
                        </aside>
                    </section>
                    <section id="pattern-matching-function-clauses">
                        <h1>Function Clauses</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code>
def cat_greet(who)
  case who
  when :owner
    'Purr!'
  when :dog
    'Hiss!'
  else
    '*ignore*'
end
cat_greet(:owner) # "Purr!"
cat_greet(:dog) # "Hiss!"
cat_greet(:sitter) # "*ignore*"
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code data-trim>
cat_greet = fn
  :owner -> "Purr!"
  :dog -> "Hiss!"
  - -> "*ignore*"
end

cat_greet.(:owner) # "Purr!"
cat_greet.(:dog) # "Hiss!"
cat_greet.(:sitter) # "*ignore*"
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Using pattern matching, we can have a function behave differently based on its inputs
                                without the need to write our own conditional logic.  In ruby, we're stuck with a
                                case statement unless the argument is a class and the responses can be made polymorphic.
                            </p>
                            <p>
                                The pattern matching is very efficient in the compiled BEAM bytecode.  If multiple
                                function clauses have to same prefix, such when matching strings or packets, the compiler
                                will produce a tree of check so that the prefix is matched first before moving on to
                                the parts of the pattern that differs.
                            </p>
                        </aside>
                    </section>
                    <section id="pattern-matching-case-statements">
                        <h1>If-else to case</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <td>
                                <pre><code data-trim>
fizz = n % 3 == 0
buzz = n % 5 == 0

if fizz && buzz
  'FizzBuzz'
elsif fizz
  'Fizz'
elsif buzz
  'Buzz'
else
  n
end
                                </code></pre>
                            </td>
                            <td>
                                <pre><code data-trim>
case {rem(n, 3), rem(n, 5), n} do
  {0, 0, _} -> "FizzBuzz"
  {0, _, _} -> "Fizz"
  {_, 0, _) -> "Buzz"
  {_, _, n} -> n
end
                                </code></pre>
                            </td>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                In Ruby, the case statement uses the triple-equals (===) operator to allow when
                                clauses that match either the exact value or be of the same Class or Regexp match the
                                argument to when.
                            </p>
                            <p>
                                In Elixir, case statements are a way to match a bunch of patterns in order the same as
                                with function clauses.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="project">
                        <h1>Project</h1>
                        <ul>
                            <li>
                                <a href="#/project-tools">Tools</a>
                            </li>
                            <li>
                                <a href="#/project-new">New</a>
                            </li>
                            <li>
                                <a href="#/project-file-layout">File Layout</a>
                            </li>
                            <li>
                                <a href="#/project-packaging">Packaging</a>
                            </li>
                            <li>
                                <a href="#/project-dependency-source">Dependency Source</a>
                            </li>
                            <li>
                                <a href="#/project-dependency-environment">Dependency Environment</a>
                            </li>
                            <li>
                                <a href="#/project-dependency-special-features">Dependency Special Features</a>
                            </li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Let's start from the a clean state and say we're creating a new project.
                            </p>
                        </aside>
                    </section>
                    <section id="project-tools">
                        <h1>Tools</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>gem list</code>
                                </td>
                                <td>
                                    <code>mix archive</code>
                                </td>
                                <td>
                                    <code>bundle help</code>
                                </td>
                                <td>
                                    <code>mix help</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>gem build *.gemspec</code>
                                </td>
                                <td>
                                    <code>mix archive.build</code>
                                </td>
                                <td>
                                    <code>gem help</code>
                                </td>
                                <td>
                                    <code>mix help</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>gem install *.gem</code>
                                </td>
                                <td>
                                    <code>mix archive.install</code>
                                </td>
                                <td>
                                    <code>rake -T</code>
                                </td>
                                <td>
                                    <code>mix help</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>gem uninstall NAME</code>
                                </td>
                                <td>
                                    <code>mix archive.uninstall NAME</code>
                                </td>
                                <td>
                                    <code>bundle outdated</code>
                                </td>
                                <td>
                                    <code>mix hex.outdated</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rm *.gem</code>
                                </td>
                                <td>
                                    <code>mix clean</code>
                                </td>
                                <td>
                                    <code>gem owner</code>
                                </td>
                                <td>
                                    <code>mix hex.owner</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>bundle list</code>
                                </td>
                                <td>
                                    <code>mix deps</code>
                                </td>
                                <td>
                                    <code>gem push</code>
                                </td>
                                <td>
                                    <code>mix hex.publish</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>bundle install</code>
                                </td>
                                <td>
                                    <code>mix deps.get</code>
                                </td>
                                <td>
                                    <code>gem query</code>
                                </td>
                                <td>
                                    <code>mix hex.search</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rm Gemfile.lock</code>
                                </td>
                                <td>
                                    <code>mix deps.unlock --all</code>
                                </td>
                                <td>
                                    <code>bundle gem</code>
                                </td>
                                <td>
                                    <code>mix new</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>bundle update</code>
                                </td>
                                <td>
                                    <code>mix deps.update --all</code>
                                </td>
                                <td>
                                    <code>
                                        rake spec
                                    </code>
                                </td>
                                <td>
                                    <code>
                                        mix test
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                 <td>
                                    <code>rake TASK1 TASK2</code>
                                </td>
                                <td>
                                    <code>mix do TASK1 TASK2</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Unlike Ruby, where you need to know whether to use <code>bundle</code>,
                                <code>gem</code>, or <code>rake</code>, everything is a <code>mix</code> task in Elixir.
                            </p>
                            <p>
                                Mix tasks are namespaced just like rake taks, but mix task use dot (.) instead of colon
                                (:).
                            </p>
                            <p>
                                Most of the <code>gem</code> command map to <code>mix archive</code> namespace tasks.
                                Most <code>bundle</code> commands map to <code>mix deps</code>, except for
                                <code>outdated</code>, which is mix hex dot outdated.
                            </p>
                            <p>
                                Any <code>gem</code> commands interacting with rubygems.org are mapped to
                                <code>mix hex</code> tasks because the rubygems.org equivalent is hex.pm.
                            </p>
                        </aside>
                    </section>
                    <section id="project-new">
                        <h1></h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>gem install bundler</code>
                                </td>
                                <td>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>bundle gem example --coc --mit --test=rspec</code><br/>
                                    <img src="images/bundle-gem.png"/>
                                </td>
                                <td>
                                    <code>mix new example</code><br/>
                                    <img src="images/mix-new.png"/>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                There is not step equivalent to <code>gem install bundler</code> for Elixir because
                                mix is part of the Elixir install.
                            </p>
                        </aside>
                    </section>
                    <section id="project-file-layout">
                        <h1>File Layout</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>example.gemspec</code>
                                </td>
                                <td>
                                    <code>mix.exs</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>.gitignore</code>
                                </td>
                                <td>
                                    <code>.gitignore</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>Gemfile</code>
                                </td>
                                <td>
                                    <code>mix.exs</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>lib/example.rb</code>
                                </td>
                                <td>
                                    <code>lib/example.ex</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>lib/example/version.rb</code>
                                </td>
                                <td>
                                    <code>mix.exs</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>README.md</code>
                                </td>
                                <td>
                                    <code>README.md</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>spec/spec_helper.rb</code>
                                </td>
                                <td>
                                    <code>test/test_helper.exs</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>spec/example_spec.rb</code>
                                </td>
                                <td>
                                    <code>test/example_test.exs</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Both <code>bundle gem</code> and <code>mix new</code> handle git ignores, a stubbed
                                packaging file, versioning, README, and tests.
                            </p>
                            <p>
                                In version 1.10, bundler really stepped up its game and now prompts for Code-of-Conduct
                                (COC), license, and automatically generates a <code>.travis.yml</code> for travis-ci.org
                            </p>
                            <p>
                                Unlike bundler's Gemfile and and rubygems' gemspec, there is not split packaging
                                and dependency management in Elixir: everything is in <code>mix.exs</code>.
                                Additionally, the version of the project is stored directly in the <code>mix.exs</code>
                                instead of being in a separate file like <code>lib/example/version.rb</code>.
                            </p>
                        </aside>
                    </section>
                    <section id="project-packaging">
                        <h1>Packaging</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
# coding: utf-8
lib = File.expand_path('../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require 'example/version'

Gem::Specification.new do |spec|
  spec.name          = "example"
  spec.version       = Example::VERSION
  spec.authors       = ["Luke Imhoff"]
  spec.email         = ["luke_imhoff@rapid7.com"]

  spec.summary       = %q{TODO: Write a short summary, because Rubygems requires one.}
  spec.description   = %q{TODO: Write a longer description or delete this line.}
  spec.homepage      = "TODO: Put your gem's website or public repo URL here."
  spec.license       = "MIT"

  spec.files         = `git ls-files -z`.split("\x0").reject { |f| f.match(%r{^(test|spec|features)/}) }
  spec.bindir        = "exe"
  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }
  spec.require_paths = ["lib"]

  spec.add_development_dependency "bundler", "~> 1.10"
  spec.add_development_dependency "rake", "~> 10.0"
  spec.add_development_dependency "rspec"
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
defmodule Example.Mixfile do
  use Mix.Project

  def project do
    [app: :example,
     version: "0.0.1",
     elixir: "~> 1.0",
     deps: deps]
  end

  def application do
    [applications: [:logger]]
  end

  defp deps do
    []
  end
end
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                As you can see at the top of mix.exs, it is a standard Elixir module and under the
                                project's Example namespace, so the version can be extracted from
                                Example.Mixfile.project at runtime without the new for a separate version file like
                                Ruby's lib/example/version.rb constants.
                            </p>
                            <p>
                                The app keyword in the project function gives the entirety of this project a name that
                                can be used to include this project in other project releases.  The applications list
                                in the applications function list the applications this project depends on at runtime.
                                In Erlang and Elixir, applications are libraries or trees of VM processes that are
                                started as a group to provide some service to other applications.
                            </p>
                            <p>
                                The version keyword in the project function sets the name of this project when it is
                                released as an application or published to hex.
                            </p>
                            <p>
                                hex.pm is the Elixir equivalent of rubygems.org.
                            </p>
                            <p>
                                The deps function lists the dev, prod, and/or test compile time dependencies.
                            </p>
                        </aside>
                    </section>
                    <section id="project-dependency-source">
                        <h1>Dependency - Source</h1>
                        <table>
                            <thead>
                            <tr>
                                <th rowspan="2">Source</th>
                                <th colspan="2">Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            <tr>
                                <th>
                                    <code>*.gemspec</code>
                                </th>
                                <th>
                                    <code>Gemfile</code>
                                </th>
                                <th>
                                    <code>mix.exs</code>
                                </th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>
                                    Packager
                                </th>
                                <td>
                                    <code>spec.add_runtime_dependency 'mydep', '~> 1.2.3'</code>
                                </td>
                                <td>
                                    <code>gem 'mydep', '~> 1.2.3'</code>
                                </td>
                                <td>
                                    <code>{:mydep, "~> 0.3.0"}</code>*
                                </td>
                            </tr>
                            <tr>
                                <th>
                                    Github
                                </th>
                                <td>
                                    &#10060;
                                </td>
                                <td>
                                    <code>gem 'mydep', github: 'myorg/mydep', tag: 'v1.2.3'</code>
                                </td>
                                <td>
                                    <code>{:mydep, github: 'myorg/mydep', tag: "v1.2.3"}</code>
                                </td>
                            </tr>
                            <tr>
                                <th>
                                    Path
                                </th>
                                <td>
                                    &#10060;
                                </td>
                                <td>
                                    <code>gem 'mydep', path: 'path/to/mydep'</code>
                                </td>
                                <td>
                                    <code>{:mydep, path: "path/to/mydep"</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <p>
                            *All mix dependencies are added to the <code>[]</code> in
                            <code>Example.MixFile.deps/0</code>
                        </p>
                        <aside class="notes">
                            <p>
                                Because rubygems and bundler grew up after Ruby was started, their individual
                                responsibilities for dependencies overlap.
                            </p>
                            <p>
                                Mix, on the other hand, was in Elixir from the beginning, and so the deps function
                                handles all sources.
                            </p>
                        </aside>
                    </section>
                    <section id="project-dependency-environment">
                        <h1>Dependency - Environment</h1>
                        <table>
                            <thead>
                            <tr>
                                <th rowspan="2">Environment</th>
                                <th colspan="2">Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            <tr>
                                <th>
                                    <code>*.gemspec</code>
                                </th>
                                <th>
                                    <code>Gemfile</code>
                                </th>
                                <th>
                                    <code>mix.exs</code>
                                </th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>development</th>
                                <td>
                                    <code>spec.add_development_dependency 'mydep', '~> 1.2.3'</code>
                                </td>
                                <td>
                                    <code>gem 'mydep', '~> 1.2.3', group: :development</code>
                                </td>
                                <td>
                                    <code>{:mydep, '~> 1.2.3', only: :dev}</code>
                                </td>
                            </tr>
                            <tr>
                                <th>test</th>
                                <td>
                                    &10060;
                                </td>
                                <td>
                                    <code>gem 'mydep', '~> 1.2.3', group: :test</code>
                                </td>
                                <td>
                                    <code>{:mydep, '~> 1.2.3', only: :test}</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <p>
                            *All mix dependencies are added to the <code>[]</code> in
                            <code>Example.MixFile.deps/0</code>
                        </p>
                    </section>
                    <section id="project-dependency-advanced-features">
                        <h1>Dependency - Advanced Features</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Name</th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Optional</td>
                                <td>
                                    <code>group optional: true</code>
                                </td>
                                <td>
                                    <code>{:mydep, '1.2.3', optional: true}</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Override</td>
                                <td>
                                    <a href="https://github.com/bundler/bundler-features/issues/20">&#10060;</a>
                                </td>
                                <td>
                                    <code>{:mydep, '1.2.3', override: true}</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                If you're only Bundler 1.10+, you'll have access to optional gems.  Otherwise, you
                                only get declared, optional dependencies using Mix.
                            </p>
                            <p>
                                Bundler has no mechanism for a project to override a version conflict between its
                                dependency's dependencies.  There has been an feature request feature open for it for
                                2 years, but its suck in debate.  Mix took the approach that a project can work out
                                version conflicts between it dependencies by overriding them.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="code">
                        <h1>Code</h1>
                        <ul>
                            <li>
                                <a href="#/code-module">Module</a>
                            </li>
                            <li>
                                <a href="#/code-writing-documentation">Writing Documentation</a>
                            </li>
                            <li>
                                <a href="#/code-reading-documentation">Reading Documentation</a>
                            </li>
                            <li>
                                <a href="#/code-function-overloading">Function Overloading</a>
                            </li>
                            <li>
                                <a href="#/code-recursion">Recursion</a>
                            </li>
                        </ul>
                    </section>
                    <section id="code-module">
                        <h1>Module</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
module Math
  def self.sum(a, b)
    a + b
  end

  def self.square(x) do
    x * x
  end
end

Math.sum(1, 2) # 3
Math.square 3 # 9
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
defmodule Math do
  def sum(a, b) do
    a + b
  end

  def square(x) do
    x * x
  end
end

Math.sum(1, 2) # 3
Math.square 3 # 9
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                So, Ruby and Elixir Modules look pretty similar.  <code>module</code> becomes
                                <code>defmodule</code>.  There's are extra <code>do</code>s for Elixir.
                            </p>
                            <p>
                                There are no objects and therefore instance methods in Elixir, so while def self dot
                                is needed for a module method in Ruby, in Elixir def is automatically a module method.
                            </p>
                            <p>
                                Like in Ruby, parentheses are optional in Elixir.
                            </p>
                        </aside>
                    </section>
                    <section id="code-writing-documentation">
                        <h1>Writing Documentation</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
# Simple math functions
module Math
  # Sums two numbers.
  #
  # @param a [Number]
  # @param b [Number]
  # @return [Number] Sum of `a` and `b`
  def self.sum(a, b)
    a + b
  end

  # Multiplies `x` by itself.
  #
  # @param x [Number]
  # @return [Number]
  def self.square(x) do
    x * x
  end
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
defmodule Math do
  @moduledoc "Simple math functions"

  @doc "Sums two numbers."
  @spec sum(number, number) :: number
  def sum(a, b) do
    a + b
  end

  @doc "Multiplies `x` by itself."
  @spec square(number) :: number
  def square(x) do
    x * x
  end
end
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                In Ruby, I'm using YARD docs because it's more structured and feature rich than rdoc.
                            </p>
                            <p>
                                While YARD docs are stuck in the comments.  Documentation and types annotations are
                                first class and retained in the compiled Module beam file.  You can access the help
                                in iex with the h/1 function.  If you want to generate html, you can use the ex_doc
                                package and publish docs to hexdocs.pm.
                            </p>
                            <p>
                                Docs are pushed to hexdocs.pm from your computer instead of being automatically generated
                                like on rubydoc.info, so you can do things you can do on rubydoc.info like publish docs
                                for a private package OR generate docs using your own plugins, which are blocked from
                                running on rubydoc.info.
                            </p>
                            <p>
                                The type annotations are optional, but if given can be used with dialyzer to check if
                                the types given match the expected and returned values from the real functions and
                                any functions that call the functons using a strategy called success typing.
                            </p>
                            <p>
                                Giving the specs here is mostly a form of documentation, so callers for the code know
                                that it works on both floats and integers.
                            </p>
                        </aside>
                    </section>
                    <section id="code-reading-documentation">
                        <h1>Reading Documentation</h1>
                        <img src="images/math-help.png"/>
                        <img src="images/math-spec.png"/>
                    </section>
                    <section id="code-function-overloading">
                        <h1>Function Overloading</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
class Rectangle
  attr_reader :height, :width

  def initialize(width, height)
    @width = width
    @height = height
  end

  def area
    width * height
  end
end

Rectangle.new(2, 3).area # 6
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="ruby" data-trim>
class Circle
  attr_reader :radius

  def initialize(radius)
    @radius = radius
  end

  def area
    Math::PI * radius * radius
  end
end

Circle.new(3).area # 28.274333882308138
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
defmodule Geometry do
  def area({:rectangle, width, height}) do
    width * height
  end

  def area({:circle, radius}) when is_number(radius) do
    :math.pi * radius * radius
  end
end

Geometry.area({:rectangle, 2, 3}) # 6
Geometry.area({:circle, 3}) # 28.274333882308138
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                A function can have multiple <code>def</code>s.  Allowing function overloading like
                                in Java, but instead of matching on the class or interface, the overloading works based
                                on pattern matching. Here, the clauses are matching on the atom and number of elements
                                in the tuple.  <code>when is_number(r)</code> is guard.  Guards are used to restrict the
                                type of parameters allowed or to enforce relationships between variable in a pattern
                                that can't be expressed directly in the pattern shape.
                            </p>
                            <p>
                                Using tagged tuples where the first element is an atom is one of the ways of adapting
                                polymorphic code in Ruby with different implementations on different classes to Elixir.
                            </p>
                            <p>
                                The tagged tuple format comes from Erlang, but Elixir has access to a better form of
                                polymorphism with Structs and Protocols, which I'll cover later.
                            </p>
                        </aside>
                    </section>
                    <section id="code-recursion">
                        <h1>Recursion</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
def sum_array(array, acc)
  if array.empty?
    acc
  else
    head, *tail = array
    sum_array(tail, acc + head)
  end
end

sum_array((0..9000).to_a, 0) # SystemStackError: stack level too deep
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
defmodule Recursion do
  def sum_list([head | tail], acc) do
    sum_list(tail, acc + head)
  end

  def sum_list([], acc) do
    acc
  end
end

0..9000 |> Enum.to_list |> Recursion.sum_list(0) # 40504500
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Ruby doesn't do tail call optimization unless a compilation flag is enabled when
                                reading in code, so most Ruby code avoids recursive solutions in favor of iteration to
                                prevent the stack overflow as seen here.
                            </p>
                            <p>
                                In Elixir since data is immutable, but tail calls are optimized, loops can be converted
                                to tail recursive calls where the result of the loop is carried in an accumulator.  The
                                base case of the loop is then to return the accumulator.  Having the base case in a
                                separate function clause makes it much more obvious that the passed in value will be the
                                return when the list is empty than when using a <code>for</code> loop or recursion with
                                <code>if</code> statements in an imperative language.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="testing">
                        <h1>Testing</h1>
                        <ul>
                            <li>
                                <a href="#/testing-frameworks">Frameworks</a>
                            </li>
                            <li>
                                <a href="#/testing-helper">Helper</a>
                            </li>
                            <li>
                                <a href="#/testing-file">File</a>
                            </li>
                            <li>
                                <a href="#/testing-output">Output</a>
                            </li>
                            <li>
                                <a href="#/testing-coverage">Coverage</a>
                            </li>
                            <li>
                                <a href="#/testing-documentation-examples">Documentation Examples</a>
                            </li>
                        </ul>
                    </section>
                    <section id="testing-frameworks">
                        <h1>Frameworks</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                                <th>Usage</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>minitest/unit</td>
                                <td>ex_unit</td>
                                <td>assertion based unit testing</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>shouldi</td>
                                <td>Nested contexts for ex_unit</td>
                            </tr>
                            <tr>
                                <td>faker</td>
                                <td>faker</td>
                                <td>Fake data for tests</td>
                            </tr>
                            <tr>
                                <td>rspec</td>
                                <td>espec</td>
                                <td>BDD tests with <code>expect</code>, <code>let</code>, <code>callbacks</code></td>
                            </tr>
                            <tr>
                                <td>cucumber</td>
                                <td>white_bread</td>
                                <td>Story-based BDD using gherkin syntax</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                For the remainder of this stack, you'll concentrate on RSpec and ExUnit because it is
                                the two frameworks I use.
                            </p>
                        </aside>
                    </section>
                    <section id="testing-helper">
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>spec/spec_helper.rb</td>
                                <td>test/test_helper.exs</td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
RSpec.configure do |config|
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.filter_run :focus
  config.run_all_when_everything_filtered = true
  config.example_status_persistence_file_path = "spec/examples.txt"
  config.disable_monkey_patching!
  config.warnings = true

  if config.files_to_run.one?
    config.default_formatter = 'doc'
  end

  config.profile_examples = 10
  config.order = :random
  Kernel.srand config.seed
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
ExUnit.start()
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                The spec slash spec helper dot R-B (<code>spec/spec_helper.rb</code>)generated by rspec
                                dash dash init (<code>rspec --init</code>) has far more configure options than the
                                test slash test helper dot E-X-S (<code>test/test_helper.ex</code>) generated by
                                <code>mix new</code>.  This is probably because RSpec is an older project and has had
                                more time to accumulate use cases that need configuration.
                            </p>
                            <p>
                                The call to ExUnit.start is starting the ExUnit application's tree of VM processes.
                            </p>
                        </aside>
                    </section>
                    <section id="testing-file">
                        <h1>Test File</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>spec/example_spec.rb</td>
                                <td>test/example_test.exs</td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim="">
RSpec.describe Example do
  it 'does not break addition' do
    expect(
      1 + 1
    ).to eq(3)
  end

  it 'does not break subtraction' do
    expect(
      1 - 1
    ).to eq(-1)
  end
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim="">
defmodule ExampleTest do
  use ExUnit.Case,
      async: true

  test "addition" do
    assert 1 + 1 ==
           3
  end

  test "subtraction" do
    assert 1 - 1 ==
           -1
  end
end
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                As mentioned on the testing frameworks slide, ex_unit is closer to Miniest than RSpec,
                                so like minitest, ExUnit uses standard modules to define the tests inside, but more
                                like RSpec, ExUnit uses a 'test' DSL to define tests.
                            </p>
                            <p>
                                While RSpec is known for its extensive expect and matcher DSL, ExUnit just uses assert
                                and normal comparison operators.
                            </p>
                            <p>
                                ExUnit, out-of-box, supports running tests in parallel using the async true option.  To
                                get parallel tests with rspec you'll need to use the parallel_test gem, which like most
                                things Ruby, has to spawn multiple OS processes to do parallelization.
                            </p>
                        </aside>
                    </section>
                    <section id="testing-output">
                        <h1>Test Output</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>rake spec</code>
                                </td>
                                <td>
                                    <code>mix test</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <img src="images/rake-spec.png"/>
                                </td>
                                <td>
                                    <img src="images/mix-test.png"/>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Both RSpec and ExUnit say which examples failed and on which line along with the total
                                number of tests and failures.  Both RSpec and ExUnit says that the comparison was done
                                with double equals (==), but only in ExUnit did I actually use double equals (==), in
                                RSpec I had to use the E-Q matcher.
                            </p>
                            <p>
                                RSpec tries to show the failing code by using the line of the call, but it only shows
                                the expect name because RSpec reads the raw file with no understanding of the code. On
                                the other hand, ExUnit is able to show the original code include the addition and
                                substraction.
                            </p>
                            <p>
                                Finally, running equivalent tests, ExUnit is both 4x faster at loading the tests
                                (0.04 vs 0.15395) and takes less than a hundredth of a second while rspec takes 2
                                hundrendths of a second.
                            </p>
                        </aside>
                    </section>
                    <section id="testing-coverage">
                        <h1>Test Coverage</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Type</th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Built-in</td>
                                <td>
                                    (no builtin reporting from Coverage library)
                                </td>
                                <td>
                                    <pre><code class="zsh" data-trim>
mix test --cover
open coverage/*.html
                                    </code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    Coverage report with ignores
                                </td>
                                <td>
                                    <pre><code class="ruby" data-trim>
# Gemfile
gem 'simplecov', group: :test, require: false

# spec/spec_helper.rb
require 'simplecov'
SimpleCov.start
                                    </code></pre>
                                    <pre><code class="zsh" data-trim>
rake spec
open coverage/index.html
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
# mix.exs
  def project do
    [ #...
      test_coverage: [tool: ExCoveralls]
    ]
  end

  def deps do
    [{:excoveralls, only: :test}]
  end

                                    </code></pre>
                                    <pre><code class="zsh" data-trim>
mix test
mix coveralls.detail
                                    </code> </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    Upload coverage reports<br/>
                                    to Coveralls.io</br>
                                    from Travis-CI.org
                                </td>
                                <td>
                                    <pre><code class="ruby" data-trim>
# Gemfile
gem 'coveralls', group: :test, require: false

# spec/spec_helper.rb
require 'coveralls'
Coveralls.wear!
                                    </code></pre>
                                    <pre><code class="zsh" data-trim>
rake spec
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
# mix.exs
  def project do
    [ #...
      test_coverage: [tool: ExCoveralls]
    ]
  end

  def deps do
    [{:excoveralls, only: :test}]
  end
                                    </code></pre>
                                    <pre><code class="zsh" data-trim>
mix coveralls.travis
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Both Ruby and Elixir have a built-in coverage library, but only Elixir can generate
                                reports using it when running mix test dash dash cover (<code>mix test --cover</code>).
                            </p>
                            <p>
                                Ruby can only generate coverage reports if simplecov is installed, but simplecov's
                                reporter add the ability to mark lines as ignored for coverage calculations.  Elixir's
                                excoveralls added stop-words, which allow lines with those words to be ignored.
                            </p>
                        </aside>
                    </section>
                    <section id="testing-documentation-examples">
                        <h1>Testing Documentation Examples</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Code</th>
                                <th>Commands</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="elixir" data-trim>
# lib/example.rb
defmodule Example
  @doc """
  Calculates line number

  ## Examples

      iex> Example.line(1, 2)
      3

  """
  def line(start, offset) do
    # correct for lines being 1-index to user
    start + offset + 1
  end
end
                                    </code></pre>
                                    <pre><code class="elixir" data-trim>
# test/example_test.ex
defmodule ExampleTest do
  use ExUnit.Case, async: true
  doctest Example
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="zsh" data-trim>
mix test
                                    </code></pre>
                                    <img src="images/mix-test-doctest.png" style="width: 100%; height: 100%"/>
                                </td>
                            </tr>
                            </tbody>
                        </table>

                        <aside class="notes">
                            <p>
                                One of the hardest things in a project is keeping documentation up-to-date.  Out of
                                date documentation makes your project harder to use as it can confuse the developer.
                                Documentation with examples is better as it goes behind same API descriptions, but
                                those examples can quickly get out-of-date.
                            </p>
                            <p>
                                To ensure that examples are correct, ExUnit has doc test, which can read all the
                                examples in a module
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="elixir">
                        <h1>Elixir</h1>
                    </section>

                    <section>
                        <h1>Concurrency</h1>
                        <pre><code data-trim>
iex> pid = spawn_link fn ->
...>   receive do
...>     {:ping, client} -> send client, :pong
...>   end
...> end
#PID<9014.59.0>
iex> send pid, {:ping, self}
{:ping, #PID<0.73.0>}
iex> flush
:pong
:ok
                        </code></pre>
                        <aside class="notes">
                            <p>
                                The <code>fn -></code> syntax is for an anonymous function like stabby lambdas in Ruby,
                                CoffeeScript, ES6, or lambda expressions in Java 8.
                            </p>
                            <p>
                                I spawn a process passing an anonymous function and have it wait to receive
                                <code>:ping</code>.  When it receive ping it will respond to the sender with
                                <code>:pong</code>.  receive will wait for message to be received or pick the first
                                message that matches from the process's mailbox.  There are no objects in Elixir, so
                                <code>self</code> returns the current process's pid instead.  <code>flush</code> dumps
                                the current processes mailbox without needing to use <code>receive</code>.
                            </p>
                            <p>
                                Sending messages between processes is very similar to how you use <code>send</code> to
                                send messages to objects.  Using mailboxes and <code>receive</code>, the process has
                                more control than objects in Ruby.  The receiving process is free to ignore the message.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="why-elixir-and-not-erlang">
                        <h1>Why Elixir and not Erlang?</h1>
                        <ul>
                            <li><a href="#/tooling">Tooling</a></li>
                            <li><a href="#/metaprogramming">Metaprogramming</a></li>
                            <li><a href="#/polymorphism">Polymorphism</a></li>
                        </ul>
                        <aside class="notes">
                            Everything I've shown so far in Elixir can be accomplished in Erlang with only a change in
                            Syntax, so the question becomes why use Elixir instead of Erlang?  It comes down to the
                            three main features José Valim wanted to added to Erlang when making Elixir: tooling,
                            metaprogramming, and polymorphism.
                        </aside>
                    </section>
                </section>
                <section>
                    <section id="tooling">
                        <h1>Tooling</h1>
                        <ul>
                            <li><a href="#/mix">mix</a></li>
                            <li><a href="#/ex_unit">ExUnit</a></li>
                            <li><a href="#/ex_doc">ExDoc</a></li>
                        </ul>
                    </section>
                    <section id="ex_unit">
                        <h1>ExUnit</h1>
                        <h2>Unit Testing</h2>
                        <ul>
                            <li>Adds <code>mix test</code></li>
                            <li>Defines DSL for defining tests</li>
                            <li>Defines DSL for checking results</li>
                        </ul>
                        <aside class="notes">
                            <code>ExUnit</code> test definition test looks like RSpec, but it uses asserts like Minitest.
                        </aside>
                    </section>
                    <section id="ex_doc">
                        <h1>ExDoc</h1>
                        <ul>
                            <li>Documentation is a first class feature of Elixir</li>
                            <li>Documentation examples can be tested with ExUnit's <code>doctest</code></li>
                            <li>Documentation can be hosts on <a href="http://hexdocs.pm">hexdocs.pm</a></li>
                        </ul>
                        <aside class="notes">
                            Go to next slides to explain each point with example code.
                        </aside>
                    </section>
                    <section>
                        <h1>Tool Demo</h1>
                        <script type="text/javascript" src="https://asciinema.org/a/20038.js" id="asciicast-20038" async></script>
                    </section>
                </section>
                <section class="stack">
                    <section id="metaprogramming">
                        <h1>Erlang Macros vs Elixir Macros</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Erlang</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Run when?</td>
                                <td>Preprocess</td>
                                <td>Compile</td>
                            </tr>
                            <tr>
                                <td>Code generation</td>
                                <td>String substitution</td>
                                <td>AST manipulation</td>
                            </tr>
                            <tr>
                                <td>Language Features</td>
                                <td>Functions with Arguments</td>
                                <td>Full</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            When programming Ruby, we're used to being able to use blocks with class-level methods to
                            call and write DSLs to define code for us.  In Erlang, the macros can only do string
                            substitution like the C preprocessor, but Elixir gives access to the full language and
                            allows manipulating the Abstract Syntax Tree, which means we can delay execution just like
                            passing blocks in Ruby.
                        </aside>
                    </section>
                    <section>
                        <h1>Elixir Macros</h1>
                        <pre><code data-trim>
defmodule ElixirLunchAndLearnTest do
  use ExUnit.Case

  test "the truth" do
    assert 1 + 1 != 2
  end
end
                        </code></pre>
                        <aside class="notes">
                            Looking at this, it looks a lot like a DSL for ruby with <code>do</code>do blocks, but
                            <code>defmodule</code> is not a keyword in Elixir equivalent to <code>module</code> in Ruby
                            or <code>class</code> in Java, instead <code>defmodule</code> is a macro. Defined as normal
                            Elixir code that is run at compile time. The same with `use`, `test`, and `assert`.
                        </aside>
                    </section>
                    <section>
                        <h1>Capture Code</h1>
                        <img src="images/macros.png"/>
                        <aside class="notes">
                            With macros Elixir can do what most languages do with keywords, but those macros can
                            manipulate other code.  For example, the line with <code>assert</code> is able to give the
                            actual code run that got the error.
                        </aside>
                    </section>
                    <section>
                        <h2>Compile Data into Code</h2>
                        <pre class="stretch"><code data-trim>
defmodule MimeTypes do
  HTTPotion.start
  HTTPotion.Response[body: body] = HTTPotion.get(
    "http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
  )

  Enum.each String.split(body, %r/\n/), fn (line) ->
    unless line == "" or line =~ %r/^#/ do
      [ mimetype | _exts ] = String.split(line)


      def is_valid?(unquote(mimetype)), do: true
    end
  end

  def is_valid?(_mimetype), do: false
end

MimeTypes.is_valid?("application/vnd.exn") #=> false
MimeTypes.is_valid?("application/json")    #=> true
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Here, we download the list of know mime-types and create functions that match the known names.
                                This way, the compiler can optimize the lookup based on prefixes and we don't need to ship
                                and parse a file at runtime.
                            </p>
                            <p>
                                This approach is also used to enable Elixir to have full Unicode
                                support including proper support for graphemes vs codepoints, such as when the accent is
                                separate from the character being accented.  Ruby doesn't handle this part of Unicode
                                correctly, which may become important as meterpreter adds unicode support.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="polymorphism">
                        <h1>Protocols</h1>
                        <ul>
                            <li>Allow extending functions to support new types</li>
                            <li>Support for protocol is separate from type definition</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Erlang doesn't have protocols, so in it you have to either fork and update a function
                                to support your new data format or write wrapper functions that handle your new data
                                type and the old data type supported by the library.
                            </p>
                            <p>
                                In Ruby, we could monkey patch a class to support new methods.  In Java, reflection
                                would have to be used to add new methods to a pre-existing class or a method would need
                                to be implemented from an interface.  In Elixir, protocols can be defined that expose
                                new methods and then implementations of that protocol can be registered for different
                                types, but importantly, the protocol and type don't need to know about each other.  The
                                implementation can be done independently and Elixir will look it up and call it when
                                using the protocol.
                            </p>
                        </aside>
                    </section>
                    <section>
                        <h1>Blank.blank?</h1>
                        <pre><code data-trim>
defprotocol Blank do
  @doc "Returns true if data is considered blank/empty"
  def blank?(data)
end
                        </code></pre>
                        <pre><code data-trim>
# Integers are never blank
defimpl Blank, for: Integer do
  def blank?(_), do: false
end

# Just empty list is blank
defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end
                        </code></pre>
                        <aside class="notes">
                            Rails developers will recognize <code>blank?</code> from <code>ActiveSupport</code>.  In
                            Ruby, ActiveSupport must open up each class and add the <code>blank?</code> method to it,
                            but in Elixir we define separate implementation for each type.  This comes from the
                            <a href="http://elixir-lang.org/getting-started/protocols.html">Getting started guide</a>.
                        </aside>
                    </section>
                    <section>
                        <h1>Structs</h1>
                        <pre><code data-trim>
defprotocol Phoenix.Param do
  def to_param(term)
end

defmodule User do
  @derive {Phoenix.Param, key: :email}
  defstruct [:id, :email]
end

user = %User{id: 1, username: "alice@example.com"}
Phoenix.Param.to_param(user) # "alice@example.com"
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Structs allow new types to be defined that can be used in protocols.  They are built on
                                top of maps, but they have compile guarantees that the keys are correct.  In Erlang,
                                it's not possible to create new data types.  The closest that can be done is records,
                                which are just tuples where the first element is an atom with the record's name, but the
                                record syntax is clunky compared to Structs.  Example taken from the Phoenix docs.
                            </p>
                            <p>
                                Here, I'm defining a User Struct, such as for a web app and I want to use the email
                                address in parameters instead of the id of the User record, so I derive an implementation
                                for the Phoenix.Param protocol.
                            </p>
                        </aside>
                    </section>
                </section>
                <section id="examples">
                    <h1>Examples</h1>
                    <ol>
                        <li><a href="#/pipes">Pipes</a></li>
                        <li><a href="#/fizz-buzz">FizzBuzz</a></li>
                        <li><a href="#/process-scaling">Process Scaling</a></li>
                    </ol>
                </section>
                <section class="stack">
                    <section>
                        <h1>Pipes</h1>
                        <ul>
                            <li>Eliminate deeply nested function calls</li>
                            <li>Eliminate throw-away temporary variables</li>
                            <li>Write shell-style pipelines between functions</li>
                        </ul>
                    </section>
                    <section>
                        <pre><code data-trim>
# deeply nested function calls
def main(argv) do
  output(process(parse_args(argv)))
end
                        </code></pre>
                        <pre><code data-trim>
# single-use variables
def main(argv) do
  parsed_args = parse_args(argv)
  processed = process(parsed_args)
  output(processed)
end
                        </code></pre>
                        <pre><code data-trim>
# Pipes
def main(argv) do
  argv
  |> parse_args
  |> process
  |> output
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                All state has to be returned from functions if not passing messages, and IO is passing
                                messages, so that means function calls have to take the output of a previous function,
                                so we'd either have to deeply nest function calls, or use variables that are assigned on
                                one line and used only on the next, but thinking about how *nix shells work, we could
                                instead make a pipeline.
                            </p>
                            <p>
                                The <code>|></code> operator takes the left operand and passes it as the first argument
                                of the right operand.  Just like piping stdout to stdin in a shell.
                            </p>
                            <p>
                                Like most of the cool features of Elixir, the <code>|></code> operator is a macro that
                                just rearranges the pipeline back to the deeply nested function call form.
                            </p>
                        </aside>
                    </section>
                </section>
                <section id="fizz-buzz">
                    <h1>If-less fizz-buzz</h1>
                    <pre><code data-trim>
defmodule FizzBuzz do
  def fizz_buzz(n), do: fizz_buzz(rem(n, 3), rem(n, 5), n)

  defp fizz_buzz(0, 0, _), do: "FizzBuzz"
  defp fizz_buzz(0, _, _), do: "Fizz"
  defp fizz_buzz(_, 0, _), do: "Buzz"
  defp fizz_buzz(_, _, n), do: n
end

FizzBuzz.fizz_buzz 10 # "Buzz"
FizzBuzz.fizz_buzz 11 # 11
FizzBuzz.fizz_buzz 12 # "Fizz"
FizzBuzz.fizz_buzz 13 # 13
FizzBuzz.fizz_buzz 14 # 14
FizzBuzz.fizz_buzz 15 # "FizzBuzz"
                    </code></pre>
                    <aside class="notes">
                        This is the classic FizzBuzz example problem, but with no explicit conditional logic.  All
                        logic is encoded in the patterns of <code>fizz_buzz/3</code>.  <code>_</code> is don't care,
                        just like in Ruby.
                    </aside>
                </section>
                <section class="stack">
                    <section id="process-scaling">
                        <h1>Process Scaling</h1>
                        <aside class="notes">
                            As I hinted at in the <a href="#/design-philosophy">Design Philosophy</a> and
                            <a href="#/whats-app">WhatsApp</a>, but how much memory does an individual process consume and
                            how fast can processes be spawned?
                        </aside>
                    </section>
                    <section>
                        <h1>Process Memory</h1>
                        <pre><code data-trim>
f = fn -> receive do
  after
    :infinity -> :ok
  end
end
{_, bytes} = Process.info(spawn(f), :memory)
bytes # 2680
                        </code></pre>
                        <aside class="notes">
                            Elixir process is only 2680 bytes of memory.  Threads on OS X are 1KB in the kernel,
                            512KB for the stack (can be as low as 16 KB).
                        </aside>
                    </section>
                    <section>
                        <h1>Process Time (1)</h1>
                        <pre class="stretch"><code data-trim>
defmodule ElixirLunchAndLearn.Chain do
  def run(n) do
    {microseconds, result} = :timer.tc(__MODULE__, :create_processes, [n])
    IO.puts "#{result} (Calculated in #{microseconds} microseconds)"
  end
end
                        </code></pre>
                        <aside class="notes">
                            <code>run</code> will be called from the command-line and will benchmark the actual work in
                            <code>create_processes</code>.
                        </aside>
                    </section>
                     <section>
                        <h1>Process Time (2)</h1>
                        <pre class="stretch"><code data-trim>
defmodule ElixirLunchAndLearn.Chain do
  def create_processes(n) do
    last = Enum.reduce 1..n,
                       self,
                       fn(_, send_to) ->
                         spawn(__MODULE__, :counter, [send_to])
                       end

    # start the count by sending
    send last, 0

    # and wait for the result to come back to us
    receive do
      final_answer when is_integer(final_answer) ->
        "Result is #{inspect final_answer}"
    end
  end
end
                       </code></pre>
                       <aside class="notes">
                           <code>create_processes</code> will create a chain of processes in memory, with one process
                           hooked to send to the previous process.  The chain will be started when the last process
                           in the chain is sent 0, then <code>receive</code> waits for the messages to travel back
                           through the chain to this process it pass itself as <code>self</code> as the first process
                           in the chain.
                       </aside>
                    </section>
                    <section>
                        <h1>Process Time (3)</h1>
                        <pre class="stretch"><code data-trim>
defmodule ElixirLunchAndLearn.Chain do
  def counter(next_pid) do
    receive do
      n ->
        send next_pid, n + 1
    end
  end
end
                        </code></pre>
                        <aside class="notes">
                            Each process simply increments the number and passes it to the <code>next_pid</code> back
                            along the chain.
                        </aside>
                    </section>
                    <section>
                        <h1>Process Time (4)</h1>
                        <pre class="stretch"><code data-trim>
> elixir --erl "+P 1000000" -r lib/elixir_lunch_and_learn/chain.ex -e "ElixirLunchAndLearn.Chain.run(1_000_000)"
Result is 1000000 (Calculated in 11658944 microseconds)
                        </code></pre>
                        <aside class="notes">
                            <p>
                                That's 1 million processes in 11 million 658 thousand and 944 microseconds, in other words
                                11.7 seconds.  That also means each process takes 11.7 microseconds to spawn, do its work
                                and go on to the next.
                            </p>
                            <p>
                                For reference, Apple's
                                <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html">
                                    own measurements
                                </a> say it takes 90 microseconds to just spawn a thread.  The OS thread limit is 10240
                                on my machine.
                            </p>
                        </aside>
                    </section>
                </section>
                  <section class="stack">
                    <section id="resources">
                        <h1>Resources</h1>
                    </section>
                    <section>
                        <h1>Intros</h1>
                        <ul>
                            <li><a href="http://howistart.org/posts/elixir/1">How I Start</a></li>
                            <li><a href="http://learnxinyminutes.com/docs/elixir/">Learn X in Y</a></li>
                        </ul>
                        <aside class="notes">
                            Code samples for the Elixir stack of slides was taken from Learn X in Y.
                        </aside>
                    </section>
                    <section>
                        <h1>Help</h1>
                        <ul>
                            <li><a href="https://webchat.freenode.net/?channels=elixir-lang">#elixir-lang</a></li>
                            <li><a href="https://groups.google.com/forum/#!forum/elixir-lang-talk">elixir-lang-talk</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Videos</h1>
                        <ul>
                            <li><a href="http://elixirsips.com">elixirsips.com</a></li>
                            <li><a href="http://infoq.com">InfoQ</a></li>
                            <li><a href="https://www.youtube.com/user/ErlangSolutions">Erlang Solutions on Youtube</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Books</h1>
                        <ul>
                            <li><a href="https://pragprog.com/book/elixir/programming-elixir">Programming Elixir</a></li>
                            <li><a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir">Metaprogramming Elixir</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Websites</h1>
                        <ul>
                            <li><a href="http://elixir-lang.org">elixir-lang.org</a></li>
                            <li><a href="https://github.com/h4cc/awesome-elixir">Awesome Elixir</a></li>
                        </ul>
                    </section>
                </section>
            </div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

                width: 2048,
                height: 1280,


                // Slide number formatting can be configured using these variables:
                //  h: current slide's horizontal index
                //  v: current slide's vertical index
                //  c: current slide index (flattened)
                //  t: total number of slides (flattened)
                slideNumber: 'c / t',

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
