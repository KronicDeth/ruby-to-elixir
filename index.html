<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Austin.RB - Ruby to Elixir</title>

		<meta name="description" content="Ruby to Elixir at Austin.RB">
		<meta name="author" content="Luke Imhoff">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Austin.RB</h1>
                    <h2>Ruby to Elixir</h2>
                    <p>2015-08-03</p>
                    <p>Luke Imhoff</p>
                    <table>
                        <tbody>
                        <tr>
                            <th>
                                <svg
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px" viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
                                            <g>
                                                <path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                                <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                                <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                                <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                            </g>
                                        </svg>
                            </th>
                            <td>luke_imhoff@rapid7.com</td>
                            <td>Kronic.Deth@gmail.com</td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="github-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                                        </svg>
                            </th>
                            <td>
                                <a href="https://github.com/limhoff-r7" target="_blank">@limhoff-r7</a>
                            </td>
                            <td>
                                <a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
                            </th>
                            <td></td>
                            <td>
                                <a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <aside class="notes">
                        I am a Senior Software Engineer for Metasploit Applications at Rapid7
                    </aside>
                </section>
                <section>
                    <h1>Outline</h1>
                    <ol>
                        <li>
                            <a href="#/overview">Overview</a>
                        </li>
                        <li>
                            <a href="#/installation">Installation</a>
                        </li>
                        <li>
                            <a href="#/interactive">Interactive</a>
                        </li>
                        <li>
                            <a href="#/types">Types</a>
                        </li>
                        <li>
                            <a href="#/control-flow">Control Flow</a>
                        </li>
                        <li>
                            <a href="#/pattern-matching">Pattern Matching</a>
                        </li>
                    </ol>
                </section>
                <section class="stack">
                    <section id="overview">
                        <h1>Overview</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th rowspan="4">Paradigms</th>
                                <th>Imperative</th>
                                <td>&#10003;</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Concurrent</th>
                                <td></td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Functional</th>
                                <td>&#10003;</td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Object-Oriented</th>
                                <td>&#10003;</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th rowspan="3">Typing</th>
                                <th>Dynamic</th>
                                <td>&#10003;</td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Duck</th>
                                <td>&#10003;</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Strong</th>
                                <td></td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th colspan="2">Mutability</th>
                                <td>Mutable</td>
                                <td>Immutable</td>
                            </tr>
                            <tr>
                                <th rowspan="2">Concurrency</th>
                                <th>CPU-bound</th>
                                <td>OS Processes</td>
                                <td>VM Processes</td>
                            </tr>
                            <tr>
                                <th>IO-bound</th>
                                <td>Threads, Fibers</td>
                                <td>VM Processes</td>
                            </tr>
                            <tr>
                                <th colspan="2">Metaprogramming</th>
                                <td>Runtime, Class Methods</td>
                                <td>Compilation, Macros</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Elixir is a functional language that is dynamically typed using immutable
                                data that is highly concurrent.
                            </p>
                            <p>
                                MRI Ruby's go-to concurrency approach of forking a process has too high of a overhead and is
                                only tolerable on system with Copy-On-Write (COW) fork, which excludes Windows.  Threading
                                and fibers in the MRI cannot get around the GIL and so only help with IO-bound code.
                            </p>
                            <p>
                                On the other hand, Elixir uses the Erlang VM, which thanks to the immutable data, can run
                                isolated processes inside the VM so fast and so cheaply that my laptop can run 1 million
                                processes in 11 seconds with processes distributed across all 4 cores.
                            </p>
                            <p>
                                Just as you learned imperative programming over mathematical thinking, you can retrain
                                to think in functional languages and even switch back and forth.  I currently switch
                                between Java, Ruby, and Elixir.  With only a few hiccups on namespace syntax and
                                string quoting.  If you're used to using <code>map</code> or <code>select</code> from
                                <code>Enumerable</code> in Ruby, you are already using functional programming.  If you
                                ever used class methods in Ruby that didn't write to class or instance variable, you're
                                already using functional programming.
                            </p>
                            <p>
                                Learning functional programming will also prepare you for the future.  If you watch
                                conference talks in other languages, such as Javascript or C++, languages are moving to
                                have more and more functional features as the programming community adapts to the
                                many-cores future.  They have figured out that locks, threads, and shared mutable
                                state is too error prone.
                            </p>
                            <p>
                                Moore's law increasing processor speed stopped 10 years ago. If you want to take
                                advantage of Moore's law now and in the future you need to write concurrent programs now
                                that can be parallelized across the additional cores of the future automatically.
                            </p>
                            <p>
                                Switching from imperative, mutable, object-oriented Ruby to functional, immutable,
                                concurrent Elixir may be intimidating, but I'll show you how easy it is to translate your
                                Ruby skills to Elixir to quickly get started learning Elixir on your own.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="installation">
                        <h1>Installation</h1>
                        <ul>
                            <li><a href="#/installation-osx">OSX</a></li>
                            <li><a href="#/installation-windows">Windows</a></li>
                            <li><a href="#/installation-linux">Linux</a></li>
                        </ul>
                    </section>
                    <section id="installation-osx">
                        <h1>OSX</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Homebrew</td>
                                <td>
                                    <code>brew install ruby</code>
                                </td>
                                <td>
                                    <code>brew install elixir</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Version Manager</td>
                                <td>
                                    <code>rvm install VERSION</code>
                                </td>
                                <td>
                                    <code>kiex install VERSION</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Ruby and Elixir both have homebrew packages and version managers.
                            </p>
                            <p>
                                If you use <code>kiex</code>, you'll need to install Erlang separately using either
                                <code>kerl</code>, spelled K-E-R-L, or homebrew
                            </p>
                        </aside>
                    </section>
                    <section id="installation-windows">
                        <h1>Windows</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Installer</td>
                                <td>
                                    <a href="http://rubyinstaller.org/">
                                        <code>rubyinstaller.exe</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://s3.amazonaws.com/s3.hex.pm/elixir-websetup.exe">
                                        <code>elixir-websetup.exe</code>
                                    </a>
                                </td>
                            </tr>
                            <tr>
                                <td>Chocolatey</td>
                                <td>
                                    <code>cinst ruby</code>
                                </td>
                                <td>
                                    <code>cinst elixir</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Both Ruby and Elixir have installers for installing the languages as a Program in Windows.
                            </p>
                            <p>
                                You can alternatively use the Chocolatey (or NuGET) package manager for Windows.
                            </p>
                        </aside>
                    </section>
                    <section id="installion-linux">
                        <h1>Linux</h1>
                        <p>Use your package manager</p>
                    </section>
                </section>
                <section class="stack">
                    <section id="interactive">
                        <h1>Interactive</h1>
                        <ul>
                            <li>
                                <a href="#/interactive-starting">Starting</a>
                            </li>
                            <li>
                                <a href="#/interactive-breaking">Breaking</a>
                            </li>
                            <li>
                                <a href="#/interactive-exiting">Exiting</a>
                            </li>
                        </ul>
                    </section>
                    <section id="interactive-starting">
                        <h1>
                            Starting Interactive
                        </h1>
                        <table>
                            <thead>
                                <tr>
                                    <th>Ruby</th>
                                    <th>Elixir</th>
                                </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>irb</code>
                                </td>
                                <td>
                                    <code>iex</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="interactive-breaking">
                        <h1>Breaking the current command</h1>
                        <table>
                            <thread>
                                <tr>
                                    <th>Ruby</th>
                                    <th>Elixir</th>
                                </tr>
                            </thread>
                            <tbody>
                            <tr>
                                <th>CTRL+C</th>
                                <th><code>#iex:break</code> on line by itself</th>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            If you make a typing mistake in <code>irb</code>, you're probably used to hitting CTRL+C,
                            but if you do that in <code>iex</code> you'll get a prompt asking whether to abort, continue,
                            kill, and some other options.  To mimic the behavior of CTRL+C from <code>irb</code>, type
                            the comment <code>iex</code> colon <code>break</code> on a line by itself.
                        </aside>
                    </section>
                    <section id="interactive-exiting">
                        <table>
                            <thread>
                                <tr>
                                    <th>Ruby</th>
                                    <th>Elixir</th>
                                </tr>
                            </thread>
                            <tbody>
                            <tr>
                                <th><code>exit</code></th>
                                <th>CTRL+C CTRL+C</th>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            A single CTRL+C in <code>iex</code> will bring up the break handler, which allows you to
                            inspect the running VM and kill individual processes.
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="types">
                        <h1>Types</h1>
                        <ul>
                            <li>
                                <a href="#/types-numeric">Numeric</a>
                            </li>
                            <li>
                                <a href="#/types-constant">Constant</a>
                            </li>
                            <li>
                                <a href="#/types-boolean">Boolean</a>
                            </li>
                            <li>
                                <a href="#/types-string">String</a>
                            </li>
                            <li>
                                <a href="#/types-regular-expression">Regular Expression</a>
                            </li>
                            <li>
                                <a href="#/types-anonymous-function">Anonymous Function</a>
                            </li>
                            <li>
                                <a href="#/types-collection">Collection</a>
                            </li>
                        </ul>
                    </section>
                    <section id="types-numeric">
                        <h1>Numeric Types</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <th>Example</th>
                                <th>Name</th>
                                <th>Example</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Integer</td>
                                <td>
                                    <code>9</code>, <code>0b1</code>, <code>0o7</code>, <code>0xF</code>
                                </td>
                                <td>Integer</td>
                                <td>
                                    <code>9</code>, <code>0b1</code>, <code>0o7</code>, <code>0xF</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Float</td>
                                <td>
                                    <code>1.2</code>, <code>3e+0</code>
                                </td>
                                <td>float</td>
                                <td>
                                    <code>1.2</code>, <code>3e+0</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Integer formats are the same for Ruby and Elixir.  They both support, decimal, binary,
                                octal, and hexadecimal.  Underscore (_) can be used to separate digit groups.
                            </p>
                            <p>
                                Float formats are the same for Ruby and Elixir.  They both support 'e' notation.
                            </p>
                        </aside>
                    </section>
                    <section id="types-constant">
                        <h1>Constant Types</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <th>Example</th>
                                <th>Name</th>
                                <th>Example</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Symbol</td>
                                <td>
                                    <code>:symbol</code>, <code>:"symbol"</code>, <code>:'symbol'</code>
                                </td>
                                <td>Atom</td>
                                <td>
                                    <code>:atom</code>, <code>:"atom"</code>, <code>:'atom'</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Class/Module name</td>
                                <td>
                                    <code>MyClass</code>, <code>MyNamespace::MyModule</code>
                                </td>
                                <td>Alias</td>
                                <td>
                                    <code>MyModule</code>, <code>MyNamespace.MyModule</code>, <code>:erlang_module</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Constant</td>
                                <td>
                                    <code>MY_CONSTANT</code>
                                </td>
                                <td>Module Attribute</td>
                                <td>
                                    <code>@my_attribute</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Symbol in Ruby just becomes the word Atom in Elixir.
                            </p>
                            <p>
                                Class/Module names and Aliases both share camel-casing, but namespaces in Class/Module
                                names are separated with colon-colon (::), while Alias names are separated with dot (.).
                                Additionally, Erlang modules are just atoms.  Aliases are called Aliases because they
                                are actually syntactic sugar with an atom starting with Elixir dot (Elixir.)
                            </p>
                            <p>
                                Your brain may read module attributes as being like class instance variables in Ruby
                                since they both start with at (@) and look like a variable, but module attributes don't
                                get assigned to with equals (=), instead they are referenced before the value to put into
                                the module attribute.  This is because module attributes can be configured to either
                                reset their value or accumulate all values passed to them.  This allows for some nice
                                features, which I'll get to later.
                            </p>
                        </aside>
                    </section>
                    <section id="types-boolean">
                        <h1>Boolean Types</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>false</code>
                                </td>
                                <td>
                                    <code>false</code>, <code>:false</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>nil</code>
                                </td>
                                <td>
                                    <code>nil</code>, <code>:nil</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>true</code>
                                </td>
                                <td>
                                    <code>true</code>, <code>:true</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                In Elixir, false, nil, and true are all just syntactic sugar for the atoms of the same
                                name.
                            </p>
                            <p>
                                Both Ruby and Elixir has falsy logic, so both false and nil are false for boolean
                                operations.
                            </p>
                        </aside>
                    </section>
                    <section id="types-string">
                        <h1>Strings</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>Format</th>
                                <td>
                                    <code>"string"</code>
                                </td>
                                <td></td>
                                <td>
                                    <code>"string"</code>
                                </td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Interpolation</th>
                                <td>
                                    <code>"Hello #{:world}"</code>
                                </td>
                                <td>&#10003;</td>
                                <td>
                                    <code>"Hello #{:world}"</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Encoding</th>
                                <td>UTF-8</td>
                                <td></td>
                                <td>UTF-8</td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Unicode Capitalization</th>
                                <td>
                                    <code>"José Valim".upcase # "JOSé VALIM"</code>
                                </td>
                                <td>&#10060;</td>
                                <td>
                                    <code>String.upcase "José Valim" # "JOSÉ VALIM"</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Unicode Graphemes Rendering</th>
                                <td>
                                    <code>"\u0065\u0301" # "é"</code>
                                </td>
                                <td>&#10003;</td>
                                <td>
                                    <code>"\x{0065}\x{0301}" # "é"</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            <tr>
                                <th>Unicode Graphemes Length</th>
                                <td>
                                    <code>"\u0065\u0301".length # 2</code>
                                </td>
                                <td>&#10060;</td>
                                <td>
                                    <code>String.length "\x{0065}\x{0301}" # 1</code>
                                </td>
                                <td>&#10003;</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Ruby and Elixir support double quoted strings with interpolation encoded as UTF-8
                            </p>
                            <p>
                                Elixir excels at proper unicode handling compared to Ruby: Elixir properly capitalizes
                                e-acute (é) in José Valim while Ruby does not; Elixir properly handles the separate
                                e and acute accent being one grapheme while Ruby counts them as 2 characters for the
                                string length.
                            </p>
                            <p>
                                If you care about what the user actually sees, you want the number of graphemes in a
                                string, not the raw bytes, so Elixir's approach is correct.
                            </p>
                        </aside>
                    </section>
                    <section id="types-regular-expression">
                        <h1>Regular Expressions</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>Literals</th>
                                <td>
                                    <ul>
                                        <li>
                                            <code>/[A-Z]+/</code>
                                        </li>
                                        <li>
                                            <code>%r{[A-Z]+}</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>~r{[A-Z]+}</code>
                                        </li>
                                        <li>
                                            <code>~r[(.*)]</code>
                                        </li>
                                        <li>
                                            <code>~r&lt;[A-Z]+&gt;</code>
                                        </li>
                                        <li>
                                            <code>~r"[A-Z]+"</code>
                                        </li>
                                        <li>
                                            <code>~r/[A-Z]+/</code>
                                        </li>
                                        <li>
                                            <code>~r([A-Z]+)</code>
                                        </li>
                                        <li>
                                            <code>~r|[A-Z]+|</code>
                                        </li>
                                        <li>
                                            <code>~r'[A-Z]+'</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <th>Compile</th>
                                <td>
                                    <code>Regexp.new "string"</code>
                                </td>
                                <td>
                                    <code>Regexp.compile! "string"</code>
                                </td>
                            </tr>
                            <tr>
                                <th>Replace</th>
                                <td>
                                  <pre><code class="ruby">
'`spec` is a task for `rake`'.gsub(
  /`(.*?)`/,
  '&lt;code&gt;\1&lt;/code&gt;'
) # "&lt;code&gt;test&lt;/code&gt; is a task for &lt;code&gt;rake&lt;/code&gt;"
                                  </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir">
Regex.replace(
  ~r/`(.*?)`/,
  "`test` is a task for `mix`",
  "&lt;code&gt;\\1&lt;/code&gt;"
) # &lt;code&gt;test&lt;/code&gt; is a task for &lt;code&gt;mix&lt;/code&gt;"
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            Unlike Ruby, which only allows
                        </aside>
                    </section>
                    <section id="types-anonymous-function">
                        <h1>Anonymous Functions</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Declaration</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add = ->(a,b){ a + b }</code>
                                        </li>
                                        <li>
                                            <code>add = lambda { |a,b| a + b }</code>
                                        </li>
                                        <li>
                                            <code>add = proc { |a,b| a + b }</code>
                                        </li>
                                        <li>
                                            <code>add = Proc.new { |a, b| a + b}</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add = fn a, b -> a + b end</code>
                                        </li>
                                        <li>
                                            <code>add = fn (a, b) -> a + b end</code>
                                        </li>
                                        <li>
                                            <code>add = &(&1 + &2)</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Calling</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add.call(1,2)</code>
                                        </li>
                                        <li>
                                            <code>add.call 1, 2</code>
                                        </li>
                                        <li>
                                            <code>add.(1,2)</code>
                                        </li>
                                        <li>
                                            <code>add[1,2]</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>add.(1,2)</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="types-collection">
                        <h1>Collections</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <th>Example</th>
                                <th>Name</th>
                                <th>Example</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Array</td>
                                <td>
                                    <code>[1,2,3]</code>
                                </td>
                                <td>Tuple</td>
                                <td>
                                    <code>[1,2,3]</code>
                                </td>
                            </tr>
                            <tr>
                                <td>Hash</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>{a: 1, b: 2}</code>
                                        </li>
                                        <li>
                                            <code>{:a => 1, :b => 2}</code>
                                        </li>
                                    </ul>
                                </td>
                                <td>Map</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>%{a: 1, b: 2}</code>
                                        </li>
                                        <li>
                                            <code>%{:a => 1, :b => 2}</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Set</td>
                                <td>
                                    <code>Set.new [1,2,3]</code>
                                </td>
                                <td>HashSet</td>
                                <td>
                                    <code>Enum.into [1,2,3], HashSet.new</code>
                                </td>
                            </tr>
                            <tr>
                                <td>&#10060;</td>
                                <td>&#10060;</td>
                                <td>Linked List</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>[1,2,3]</code>
                                        </li>
                                        <li>
                                            <code>[1 | [2 | [3 | []]]]</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>&#10060;</td>
                                <td>&#10060;</td>
                                <td>Keyword List</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>[a: 1, a: 2, b: 3]</code>
                                        </li>
                                        <li>
                                            <code>[{:a, 1}, {:a, 2}, {:b, 3}]</code>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Arrays and tuples are both contiguous in memory, but tuples are a fixed size while Ruby
                                Arrays are resizable.  Both allow lookup by index.
                            </p>
                            <p>
                                Both Set and HashSet are built on top of Hashes and don't support a built-in syntax
                                for initialization, and so here are populated using an Array and Linked List,
                                respectively.
                            </p>
                            <p>
                                Linked list can access the first (head) element or the rest (tail) elements quickly.
                                The Ruby standard library has linked list implementation.  The
                                <a href="https://github.com/hamstergem/hamster#list-api-documentation">
                                    hamster gem has <code>Hamster.list</code>
                                </a>.
                            </p>
                            <p>
                                A Keyword List allows multiple values for the same key and is implemented as a list
                                of 2-tuples.  So, not as efficient as a map, which is built is optimized, but useful
                                for named function arguments where an option can be repeated.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="control-flow">
                        <h1>Control Flow</h1>
                        <ul>
                            <li>
                                <a href="#/control-flow-boolean">Boolean</a>
                            </li>
                            <li>
                                <a href="#/control-flow-rescue">Rescue</a>
                            </li>
                            <li>
                                <a href="#/control-flow-catch">Catch</a>
                            </li>
                        </ul>
                    </section>
                    <section id="control-flow-boolean">
                        <h1>Boolean Control Flow</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby">
if false
  'This will never be seen'
else
  'This will'
end
                                    </code></pre>

                                </td>
                                <td>
                                    <pre><code class="elixir">
if false do
  "This will never be seen"
else
  "This will"
end
                                    </code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code class="ruby">
unless true
  'This will never be seen'
else
  'This will'
end
                                    </code></pre>

                                </td>
                                <td>
                                    <pre><code class="elixir">
unless true do
  "This will never be seen"
else
  "This will"
end
                                    </code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code class="ruby">
if one
  'one is true'
elsif two
  'two is true'
else
  'neither one nor two is true'
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir">
cond do
  one -> "one is true"
  two -> "two is true"
  true -> "neight one nor two is true"
end
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Take note that if and unless look the same in Ruby and Elixir, except that Elixir has a
                                'do' after the condition.  I'll explain why that is later.
                            </p>
                            <p>
                                Although Elixir has control flow, it is rare in idiomatic code to see if, unless or
                                cond.  It is much more likely to see pattern matching, which I'll cover next.
                            </p>
                        </aside>
                    </section>
                    <section id="control-flow-rescue">
                        <h1>Rescuing Exceptions</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                  <pre><code class="ruby" data-trim>
begin
  raise 'some error'
rescue RuntimeError => runtime_error
  puts runtime_error
rescue ArgumentError
  puts 'argument error occurred'
rescue => exception
  puts exception
rescue
  puts 'some exception'
else
  puts 'no exception'
ensure
  puts 'always runs'
end
                                  </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
try do
  raise "some error"
rescue
  x in [RuntimeError] ->
    IO.puts x.message
  ArgumentError ->
    IO.puts "argument error occurred"
  error ->
    IO.puts error
  _ ->
    IO.puts "some error"
else
  IO.puts "no error"
after
  puts "always run"
end
                                    </code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>begin</code>
                                </td>
                                <td>
                                    <code>try do</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue Klass => instance</code>
                                </td>
                                <td>
                                    <code>variable in [Alias] -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue Klass</code>
                                </td>
                                <td>
                                    <code>Alias -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue => exception</code>
                                </td>
                                <td>
                                    <code>error -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>rescue</code>
                                </td>
                                <td>
                                    <code>_ -></code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>else</code>
                                </td>
                                <td>
                                    <code>else</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>ensure</code>
                                </td>
                                <td>
                                    <code>after</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>end</code>
                                </td>
                                <td>
                                    <code>end</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="control-flow-catch">
                        <h1>Catching Throws And Exits</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code class="ruby" data-trim>
answer = nil
catch (:done) do
  answer = 42
  throw :done
end
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
try do
  name = "Alice"
  throw("Hello", name)
  exit "I am exiting"
catch
  {greeting, name} ->
    IO.puts "#{greeting} to you, #{name}"
  :exit, _ -> "not really"
after
  IO.puts "Nothing thrown"
end
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Catch and throw are quite esoteric in ruby.  The only case I can think of them being used
                                in production is in parts of Rack.
                            </p>
                            <p>
                                In Elixir, catch and throw is only meant for use when you can't send a message up the
                                stack any other way.  However, Elixir's catch is far more flexible as the throw and
                                catch don't have to agree on single symbol to match on the way Ruby does.
                            </p>
                            <p>
                                Catch and exit are used all the time to monitor for VM processes exiting.  VM processes
                                monitoring each other is part of the resiliency features of Elixir, so it is very
                                important.  Most of the time, the standard library will handle the exit catching behind
                                the scenes.
                            </p>
                            <p>
                                You may have also noticed that rescuing exceptions and catching throws and exits all use
                                try.  It is actually possible to rescue exceptions and catch throws and exits in the
                                same try.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="pattern-matching">
                        <h1>Pattern Matching</h1>
                        <ul>
                            <li>
                                <a href="#/pattern-matching-variable-match">Assignment to Match</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-destructing-to-match">Destructuring to Match</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-argument-error-to-match">ArgumentError to Match</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-function-clauses">Function Clauses</a>
                            </li>
                            <li>
                                <a href="#/pattern-matching-case-statements">If Else to Case Statements</a>
                            </li>
                        </ul>
                    </section>
                    <section id="pattern-matching-variable-match">
                        <h1>Ruby Assignment to Elixir Matching</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Step</th>
                                <th></th>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>
                                    1
                                </th>
                                <th>
                                    <code>foo = 1</code>
                                </th>
                                <td>
                                    <code>foo</code> is <code>1</code>
                                </td>
                                <td>
                                    <code>foo</code> is <code>1</code>
                                </td>
                            </tr>
                            <tr>
                                <th>2</th>
                                <th>
                                    <code>1 = foo</code>
                                </th>
                                <td>
                                    SyntaxError
                                </td>
                                <td>
                                    <code>foo</code> is <code>1</code>
                                </td>
                            </tr>
                            <tr>
                                <th>3</th>
                                <th>
                                    <code>2 = foo</code>
                                </th>
                                <td>
                                    SyntaxError
                                </td>
                                <td>
                                    ** (MatchError) no match of right hand side value: 1
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                In Elixir, the equals sign (=) is the match operator.  The match operator should not be
                                thought of as assignment, but instead of trying to get the two sides of the equals sign
                                to match, which is why you can do foo equals 1 or 1 equals foo.
                            </p>
                            <p>
                                However, after already doing foo equals 1 (foo = 1) you can't do 2 equals foo because
                                the match operator will only rebind a variable if it is on the left-hand side.
                            </p>
                        </aside>
                    </section>
                    <section id="pattern-matching-destructing-to-match">
                        <h1>Destructuring to Match</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>a, b = [1, 2]</code>
                                </td>
                                <td>
                                    <code>a = 1</code><br/>
                                    <code>b = 2</code>

                                </td>
                                <td>
                                    <code>{a, b} = {1, 2}</code>
                                </td>
                                <td>
                                    <code>a = 1</code><br/>
                                    <code>b = 2</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>_, b = [1, 2]</code>
                                </td>
                                <td>
                                    <code>b = 2</code>
                                </td>
                                <td>
                                    <code>{_, b} = {1, 2}</code>
                                </td>
                                <td>
                                    <code>b = 2</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>a, b* = [1, 2, 3]</code>
                                </td>
                                <td>
                                    <code>a = 1</code><br/>
                                    <code>b = [2, 3]</code>
                                </td>
                                <td>
                                    <code>[a | b] = [1, 2, 3] # a = 1; b = [2,3]</code>
                                </td>
                                <td>
                                    <code></code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="pattern-matching-argument-error-to-match">
                        <h1>ArgumentError to Match</h1>
                        <table>
                            <thead>
                            <tr>
                                <th colspan="2">Ruby</th>
                                <th colspan="2">Elixir</th>
                            </tr>
                            <tr>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                                <th>Expression</th>
                                <th>Variable Value(s)</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code>
a, b = [nil, 2]
unless a == 1
  raise ArgumentError,
        "a should be 1"
end
                                    </code></pre>
                                </td>
                                <td>
                                    ArgumentError: a should be 1
                                </td>
                                <td>
                                    <pre><code class="elixir" data-trim>
{1, b} = {0, 2}
                                    </code></pre>
                                </td>
                                <td>
                                    ** (MatchError) no match of right hand side value: {nil, 2}
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <pre><code data-trim>
opening, closing = [:td, :th]
unless opening == closing
  raise ArgumentError,
        "opening and closing tag don't match"
end
                                    </code></pre>
                                </td>
                                <td>
                                    ArgumentError: opening and closing tag don't match
                                </td>
                                <td>
                                    <pre><code data-trim>
{tag, tag} = {:td, :th}
                                    </code></pre>
                                </td>
                                <td>
                                    * (MatchError) no match of right hand side value: {:td, :th}
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Instead of destructuring an argument and then checking its value as would be required in
                                Ruby, you can put the expected value into the pattern in Elixir and have Elixir check
                                the value for you.
                            </p>
                            <p>
                                The patterns automatically will enforce that when the same variable is used more than
                                once it must have the same value.  For example, you could check the closing and opening
                                tag match when parsing XML.
                            </p>
                        </aside>
                    </section>
                    <section id="pattern-matching-function-clauses">
                        <h1>Function Clauses</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <pre><code>
def cat_greet(who)
  case who
  when :owner
    'Purr!'
  when :dog
    'Hiss!'
  else
    '*ignore*'
end
cat_greet(:owner) # "Purr!"
cat_greet(:dog) # "Hiss!"
cat_greet(:sitter) # "*ignore*"
                                    </code></pre>
                                </td>
                                <td>
                                    <pre><code data-trim>
cat_greet = fn
  :owner -> "Purr!"
  :dog -> "Hiss!"
  - -> "*ignore*"
end

cat_greet.(:owner) # "Purr!"
cat_greet.(:dog) # "Hiss!"
cat_greet.(:sitter) # "*ignore*"
                                    </code></pre>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Using pattern matching, we can have a function behave differently based on its inputs
                                without the need to write our own conditional logic.  In ruby, we're stuck with a
                                case statement unless the argument is a class and the responses can be made polymorphic.
                            </p>
                            <p>
                                The pattern matching is very efficient in the compiled BEAM bytecode.  If multiple
                                function clauses have to same prefix, such when matching strings or packets, the compiler
                                will produce a tree of check so that the prefix is matched first before moving on to
                                the parts of the pattern that differs.
                            </p>
                        </aside>
                    </section>
                    <section id="pattern-matching-case-statements">
                        <h1>If-else to case</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Ruby</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <td>
                                <pre><code data-trim>
fizz = n % 3 == 0
buzz = n % 5 == 0

if fizz && buzz
  'FizzBuzz'
elsif fizz
  'Fizz'
elsif buzz
  'Buzz'
else
  n
end
                                </code></pre>
                            </td>
                            <td>
                                <pre><code data-trim>
case {rem(n, 3), rem(n, 5), n} do
  {0, 0, _} -> "FizzBuzz"
  {0, _, _} -> "Fizz"
  {_, 0, _) -> "Buzz"
  {_, _, n} -> n
end
                                </code></pre>
                            </td>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                In Ruby, the case statement uses the triple-equals (===) operator to allow when
                                clauses that match either the exact value or be of the same Class or Regexp match the
                                argument to when.
                            </p>
                            <p>
                                In Elixir, case statements are a way to match a bunch of patterns in order the same as
                                with function clauses.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="elixir">
                        <h1>Elixir</h1>
                    </section>
                    <section>
                        <h1>Modules and Functions</h1>
                        <pre><code data-trim>
defmodule Math do
  def sum(a, b) do
    a + b
  end

  def square(x) do
    x * x
  end
end

Math.sum(1, 2) # 3
Math.square 3 # 9
                        </code></pre>
                        <aside class="notes">
                            Code is defined in Modules with <code>defmodule</code>.  Functions are defined with
                            <code>def</code>.  Functions are called as <code>Module</code>.<code>function</code>.
                            Parentheses are optional.
                        </aside>
                    </section>
                    <section>
                        <h1>Pattern Matching and Guards</h1>
                        <pre><code data-trim>
defmodule Geometry do
  def area({:rectangle, w, h}) do
    w * h
  end

  def area({:circle, r}) when is_number(r) do
    3.14 * r * r
  end
end

Geometry.area({:rectangle, 2, 3}) #=> 6
Geometry.area({:circle, 3})       #=> 28.25999999999999801048
                        </code></pre>
                        <aside class="notes">
                            A function can have multiple <code>def</code>s.  Allowing function overloading like
                            in Java, but instead of matching on the class or interface, the overloading works based on
                            pattern matching. Here, the clauses are matching on the atom and number of elements in the
                            tuple.  <code>when is_number(r)</code> is guard.  Guards are used to restrict the type of
                            parameters allowed or to enforce relationships between variable in a pattern that can't be
                            expressed directly in the pattern shape.
                        </aside>
                    </section>
                    <section>
                        <h1>Recursion</h1>
                        <pre><code data-trim>
defmodule Recursion do
  def sum_list([head | tail], acc) do
    sum_list(tail, acc + head)
  end

  def sum_list([], acc) do
    acc
  end
end

Recursion.sum_list([1,2,3], 0) #=> 6
                        </code></pre>
                        <aside class="notes">
                            Since data is immutable, but tail calls are optimized, loops can be converted to tail recursive
                            calls where the result of the loop is carried in an accumulator.  The base case of the loop is
                            then to return the accumulator.  Having the base case in a separate function clause makes it much
                            more obvious that the passed in value will be the return when the list is empty than when using
                            a <code>for</code> loop or recursion with <code>if</code> statements in an imperative language.
                        </aside>
                    </section>
                    <section>
                        <h1>Concurrency</h1>
                        <pre><code data-trim>
iex> pid = spawn_link fn ->
...>   receive do
...>     {:ping, client} -> send client, :pong
...>   end
...> end
#PID<9014.59.0>
iex> send pid, {:ping, self}
{:ping, #PID<0.73.0>}
iex> flush
:pong
:ok
                        </code></pre>
                        <aside class="notes">
                            <p>
                                The <code>fn -></code> syntax is for an anonymous function like stabby lambdas in Ruby,
                                CoffeeScript, ES6, or lambda expressions in Java 8.
                            </p>
                            <p>
                                I spawn a process passing an anonymous function and have it wait to receive
                                <code>:ping</code>.  When it receive ping it will respond to the sender with
                                <code>:pong</code>.  receive will wait for message to be received or pick the first
                                message that matches from the process's mailbox.  There are no objects in Elixir, so
                                <code>self</code> returns the current process's pid instead.  <code>flush</code> dumps
                                the current processes mailbox without needing to use <code>receive</code>.
                            </p>
                            <p>
                                Sending messages between processes is very similar to how you use <code>send</code> to
                                send messages to objects.  Using mailboxes and <code>receive</code>, the process has
                                more control than objects in Ruby.  The receiving process is free to ignore the message.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="why-elixir-and-not-erlang">
                        <h1>Why Elixir and not Erlang?</h1>
                        <ul>
                            <li><a href="#/tooling">Tooling</a></li>
                            <li><a href="#/metaprogramming">Metaprogramming</a></li>
                            <li><a href="#/polymorphism">Polymorphism</a></li>
                        </ul>
                        <aside class="notes">
                            Everything I've shown so far in Elixir can be accomplished in Erlang with only a change in
                            Syntax, so the question becomes why use Elixir instead of Erlang?  It comes down to the
                            three main features José Valim wanted to added to Erlang when making Elixir: tooling,
                            metaprogramming, and polymorphism.
                        </aside>
                    </section>
                </section>
                <section>
                    <section id="tooling">
                        <h1>Tooling</h1>
                        <ul>
                            <li><a href="#/mix">mix</a></li>
                            <li><a href="#/ex_unit">ExUnit</a></li>
                            <li><a href="#/ex_doc">ExDoc</a></li>
                        </ul>
                    </section>
                    <section id="mix">
                        <h1>Mix</h1>
                        <h2>Rake + Bundler</h2>
                        <ul>
                            <li>Create projects</li>
                            <li>Manages dependencies</li>
                            <li>Compiles code and dependencies</li>
                            <li>Runs tests</li>
                        </ul>
                        <aside class="notes">
                            The Erlang ecosystem for build tools is split between 3 different tools.  It has no package
                            manager or package repository like rubygems.org.  Elixir on the other hand has
                            <code>mix</code> for managing dependencies and <code>hex.pm</code> for package hosting.
                            <code>hex</code> has caught on so well, the next generation Erlang build tool,
                            <code>rebar3</code> will support <code>hex</code> packages.
                        </aside>
                    </section>
                    <section id="ex_unit">
                        <h1>ExUnit</h1>
                        <h2>Unit Testing</h2>
                        <ul>
                            <li>Adds <code>mix test</code></li>
                            <li>Defines DSL for defining tests</li>
                            <li>Defines DSL for checking results</li>
                        </ul>
                        <aside class="notes">
                            <code>ExUnit</code> test definition test looks like RSpec, but it uses asserts like Minitest.
                        </aside>
                    </section>
                    <section id="ex_doc">
                        <h1>ExDoc</h1>
                        <ul>
                            <li>Documentation is a first class feature of Elixir</li>
                            <li>Documentation examples can be tested with ExUnit's <code>doctest</code></li>
                            <li>Documentation can be hosts on <a href="http://hexdocs.pm">hexdocs.pm</a></li>
                        </ul>
                        <aside class="notes">
                            Go to next slides to explain each point with example code.
                        </aside>
                    </section>
                    <section>
                        <pre class="stretch"><code data-trim>
defmodule Atom do
  @moduledoc """
  Convenience functions for working with atoms.
  See also `Kernel.is_atom/1`.
  """

  @doc """
  Converts an atom to a string.

  Inlined by the compiler.

  ## Examples

      iex> Atom.to_string(:foo)
      "foo"
  """
  @spec to_string(atom) :: String.t
  def to_string(atom) do
    :erlang.atom_to_binary(atom, :utf8)
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Modules can be documented with <code>@moduledoc</code>.  Functions can be documented with
                                <code>@doc</code>.  Neither of these are keywords, but instead the <code>@</code>
                                variables are Module attributes, which are used like constants in Elixir.  Because the
                                documentation isn't comments, but stored in variable it can be retrieved from the
                                running system.  In fact, you can <code>h Atom.to_string</code> to get the function doc
                                in <code>iex</code>
                            </p>
                            <p>
                                The indented example that starts with <code>iex></code> will be detected by
                                <code>doctest</code> in ExUnit and the example will be checked for correctness.
                            </p>
                            <p>
                                Retrieving documentation for running code instead of a separate, preprocessed output
                                isn't possible in Ruby and testing documentation examples is only possible with YARD
                                plugins.
                            </p>
                        </aside>
                    </section>
                    <section>
                        <h1>Tool Demo</h1>
                        <script type="text/javascript" src="https://asciinema.org/a/20038.js" id="asciicast-20038" async></script>
                    </section>
                </section>
                <section class="stack">
                    <section id="metaprogramming">
                        <h1>Erlang Macros vs Elixir Macros</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Erlang</th>
                                <th>Elixir</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Run when?</td>
                                <td>Preprocess</td>
                                <td>Compile</td>
                            </tr>
                            <tr>
                                <td>Code generation</td>
                                <td>String substitution</td>
                                <td>AST manipulation</td>
                            </tr>
                            <tr>
                                <td>Language Features</td>
                                <td>Functions with Arguments</td>
                                <td>Full</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            When programming Ruby, we're used to being able to use blocks with class-level methods to
                            call and write DSLs to define code for us.  In Erlang, the macros can only do string
                            substitution like the C preprocessor, but Elixir gives access to the full language and
                            allows manipulating the Abstract Syntax Tree, which means we can delay execution just like
                            passing blocks in Ruby.
                        </aside>
                    </section>
                    <section>
                        <h1>Elixir Macros</h1>
                        <pre><code data-trim>
defmodule ElixirLunchAndLearnTest do
  use ExUnit.Case

  test "the truth" do
    assert 1 + 1 != 2
  end
end
                        </code></pre>
                        <aside class="notes">
                            Looking at this, it looks a lot like a DSL for ruby with <code>do</code>do blocks, but
                            <code>defmodule</code> is not a keyword in Elixir equivalent to <code>module</code> in Ruby
                            or <code>class</code> in Java, instead <code>defmodule</code> is a macro. Defined as normal
                            Elixir code that is run at compile time. The same with `use`, `test`, and `assert`.
                        </aside>
                    </section>
                    <section>
                        <h1>Capture Code</h1>
                        <img src="images/macros.png"/>
                        <aside class="notes">
                            With macros Elixir can do what most languages do with keywords, but those macros can
                            manipulate other code.  For example, the line with <code>assert</code> is able to give the
                            actual code run that got the error.
                        </aside>
                    </section>
                    <section>
                        <h2>Compile Data into Code</h2>
                        <pre class="stretch"><code data-trim>
defmodule MimeTypes do
  HTTPotion.start
  HTTPotion.Response[body: body] = HTTPotion.get(
    "http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
  )

  Enum.each String.split(body, %r/\n/), fn (line) ->
    unless line == "" or line =~ %r/^#/ do
      [ mimetype | _exts ] = String.split(line)


      def is_valid?(unquote(mimetype)), do: true
    end
  end

  def is_valid?(_mimetype), do: false
end

MimeTypes.is_valid?("application/vnd.exn") #=> false
MimeTypes.is_valid?("application/json")    #=> true
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Here, we download the list of know mime-types and create functions that match the known names.
                                This way, the compiler can optimize the lookup based on prefixes and we don't need to ship
                                and parse a file at runtime.
                            </p>
                            <p>
                                This approach is also used to enable Elixir to have full Unicode
                                support including proper support for graphemes vs codepoints, such as when the accent is
                                separate from the character being accented.  Ruby doesn't handle this part of Unicode
                                correctly, which may become important as meterpreter adds unicode support.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="polymorphism">
                        <h1>Protocols</h1>
                        <ul>
                            <li>Allow extending functions to support new types</li>
                            <li>Support for protocol is separate from type definition</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Erlang doesn't have protocols, so in it you have to either fork and update a function
                                to support your new data format or write wrapper functions that handle your new data
                                type and the old data type supported by the library.
                            </p>
                            <p>
                                In Ruby, we could monkey patch a class to support new methods.  In Java, reflection
                                would have to be used to add new methods to a pre-existing class or a method would need
                                to be implemented from an interface.  In Elixir, protocols can be defined that expose
                                new methods and then implementations of that protocol can be registered for different
                                types, but importantly, the protocol and type don't need to know about each other.  The
                                implementation can be done independently and Elixir will look it up and call it when
                                using the protocol.
                            </p>
                        </aside>
                    </section>
                    <section>
                        <h1>Blank.blank?</h1>
                        <pre><code data-trim>
defprotocol Blank do
  @doc "Returns true if data is considered blank/empty"
  def blank?(data)
end
                        </code></pre>
                        <pre><code data-trim>
# Integers are never blank
defimpl Blank, for: Integer do
  def blank?(_), do: false
end

# Just empty list is blank
defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end
                        </code></pre>
                        <aside class="notes">
                            Rails developers will recognize <code>blank?</code> from <code>ActiveSupport</code>.  In
                            Ruby, ActiveSupport must open up each class and add the <code>blank?</code> method to it,
                            but in Elixir we define separate implementation for each type.  This comes from the
                            <a href="http://elixir-lang.org/getting-started/protocols.html">Getting started guide</a>.
                        </aside>
                    </section>
                    <section>
                        <h1>Structs</h1>
                        <pre><code data-trim>
defprotocol Phoenix.Param do
  def to_param(term)
end

defmodule User do
  @derive {Phoenix.Param, key: :email}
  defstruct [:id, :email]
end

user = %User{id: 1, username: "alice@example.com"}
Phoenix.Param.to_param(user) # "alice@example.com"
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Structs allow new types to be defined that can be used in protocols.  They are built on
                                top of maps, but they have compile guarantees that the keys are correct.  In Erlang,
                                it's not possible to create new data types.  The closest that can be done is records,
                                which are just tuples where the first element is an atom with the record's name, but the
                                record syntax is clunky compared to Structs.  Example taken from the Phoenix docs.
                            </p>
                            <p>
                                Here, I'm defining a User Struct, such as for a web app and I want to use the email
                                address in parameters instead of the id of the User record, so I derive an implementation
                                for the Phoenix.Param protocol.
                            </p>
                        </aside>
                    </section>
                </section>
                <section id="examples">
                    <h1>Examples</h1>
                    <ol>
                        <li><a href="#/pipes">Pipes</a></li>
                        <li><a href="#/fizz-buzz">FizzBuzz</a></li>
                        <li><a href="#/process-scaling">Process Scaling</a></li>
                    </ol>
                </section>
                <section class="stack">
                    <section>
                        <h1>Pipes</h1>
                        <ul>
                            <li>Eliminate deeply nested function calls</li>
                            <li>Eliminate throw-away temporary variables</li>
                            <li>Write shell-style pipelines between functions</li>
                        </ul>
                    </section>
                    <section>
                        <pre><code data-trim>
# deeply nested function calls
def main(argv) do
  output(process(parse_args(argv)))
end
                        </code></pre>
                        <pre><code data-trim>
# single-use variables
def main(argv) do
  parsed_args = parse_args(argv)
  processed = process(parsed_args)
  output(processed)
end
                        </code></pre>
                        <pre><code data-trim>
# Pipes
def main(argv) do
  argv
  |> parse_args
  |> process
  |> output
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                All state has to be returned from functions if not passing messages, and IO is passing
                                messages, so that means function calls have to take the output of a previous function,
                                so we'd either have to deeply nest function calls, or use variables that are assigned on
                                one line and used only on the next, but thinking about how *nix shells work, we could
                                instead make a pipeline.
                            </p>
                            <p>
                                The <code>|></code> operator takes the left operand and passes it as the first argument
                                of the right operand.  Just like piping stdout to stdin in a shell.
                            </p>
                            <p>
                                Like most of the cool features of Elixir, the <code>|></code> operator is a macro that
                                just rearranges the pipeline back to the deeply nested function call form.
                            </p>
                        </aside>
                    </section>
                </section>
                <section id="fizz-buzz">
                    <h1>If-less fizz-buzz</h1>
                    <pre><code data-trim>
defmodule FizzBuzz do
  def fizz_buzz(n), do: fizz_buzz(rem(n, 3), rem(n, 5), n)

  defp fizz_buzz(0, 0, _), do: "FizzBuzz"
  defp fizz_buzz(0, _, _), do: "Fizz"
  defp fizz_buzz(_, 0, _), do: "Buzz"
  defp fizz_buzz(_, _, n), do: n
end

FizzBuzz.fizz_buzz 10 # "Buzz"
FizzBuzz.fizz_buzz 11 # 11
FizzBuzz.fizz_buzz 12 # "Fizz"
FizzBuzz.fizz_buzz 13 # 13
FizzBuzz.fizz_buzz 14 # 14
FizzBuzz.fizz_buzz 15 # "FizzBuzz"
                    </code></pre>
                    <aside class="notes">
                        This is the classic FizzBuzz example problem, but with no explicit conditional logic.  All
                        logic is encoded in the patterns of <code>fizz_buzz/3</code>.  <code>_</code> is don't care,
                        just like in Ruby.
                    </aside>
                </section>
                <section class="stack">
                    <section id="process-scaling">
                        <h1>Process Scaling</h1>
                        <aside class="notes">
                            As I hinted at in the <a href="#/design-philosophy">Design Philosophy</a> and
                            <a href="#/whats-app">WhatsApp</a>, but how much memory does an individual process consume and
                            how fast can processes be spawned?
                        </aside>
                    </section>
                    <section>
                        <h1>Process Memory</h1>
                        <pre><code data-trim>
f = fn -> receive do
  after
    :infinity -> :ok
  end
end
{_, bytes} = Process.info(spawn(f), :memory)
bytes # 2680
                        </code></pre>
                        <aside class="notes">
                            Elixir process is only 2680 bytes of memory.  Threads on OS X are 1KB in the kernel,
                            512KB for the stack (can be as low as 16 KB).
                        </aside>
                    </section>
                    <section>
                        <h1>Process Time (1)</h1>
                        <pre class="stretch"><code data-trim>
defmodule ElixirLunchAndLearn.Chain do
  def run(n) do
    {microseconds, result} = :timer.tc(__MODULE__, :create_processes, [n])
    IO.puts "#{result} (Calculated in #{microseconds} microseconds)"
  end
end
                        </code></pre>
                        <aside class="notes">
                            <code>run</code> will be called from the command-line and will benchmark the actual work in
                            <code>create_processes</code>.
                        </aside>
                    </section>
                     <section>
                        <h1>Process Time (2)</h1>
                        <pre class="stretch"><code data-trim>
defmodule ElixirLunchAndLearn.Chain do
  def create_processes(n) do
    last = Enum.reduce 1..n,
                       self,
                       fn(_, send_to) ->
                         spawn(__MODULE__, :counter, [send_to])
                       end

    # start the count by sending
    send last, 0

    # and wait for the result to come back to us
    receive do
      final_answer when is_integer(final_answer) ->
        "Result is #{inspect final_answer}"
    end
  end
end
                       </code></pre>
                       <aside class="notes">
                           <code>create_processes</code> will create a chain of processes in memory, with one process
                           hooked to send to the previous process.  The chain will be started when the last process
                           in the chain is sent 0, then <code>receive</code> waits for the messages to travel back
                           through the chain to this process it pass itself as <code>self</code> as the first process
                           in the chain.
                       </aside>
                    </section>
                    <section>
                        <h1>Process Time (3)</h1>
                        <pre class="stretch"><code data-trim>
defmodule ElixirLunchAndLearn.Chain do
  def counter(next_pid) do
    receive do
      n ->
        send next_pid, n + 1
    end
  end
end
                        </code></pre>
                        <aside class="notes">
                            Each process simply increments the number and passes it to the <code>next_pid</code> back
                            along the chain.
                        </aside>
                    </section>
                    <section>
                        <h1>Process Time (4)</h1>
                        <pre class="stretch"><code data-trim>
> elixir --erl "+P 1000000" -r lib/elixir_lunch_and_learn/chain.ex -e "ElixirLunchAndLearn.Chain.run(1_000_000)"
Result is 1000000 (Calculated in 11658944 microseconds)
                        </code></pre>
                        <aside class="notes">
                            <p>
                                That's 1 million processes in 11 million 658 thousand and 944 microseconds, in other words
                                11.7 seconds.  That also means each process takes 11.7 microseconds to spawn, do its work
                                and go on to the next.
                            </p>
                            <p>
                                For reference, Apple's
                                <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html">
                                    own measurements
                                </a> say it takes 90 microseconds to just spawn a thread.  The OS thread limit is 10240
                                on my machine.
                            </p>
                        </aside>
                    </section>
                </section>
                  <section class="stack">
                    <section id="resources">
                        <h1>Resources</h1>
                    </section>
                    <section>
                        <h1>Intros</h1>
                        <ul>
                            <li><a href="http://howistart.org/posts/elixir/1">How I Start</a></li>
                            <li><a href="http://learnxinyminutes.com/docs/elixir/">Learn X in Y</a></li>
                        </ul>
                        <aside class="notes">
                            Code samples for the Elixir stack of slides was taken from Learn X in Y.
                        </aside>
                    </section>
                    <section>
                        <h1>Help</h1>
                        <ul>
                            <li><a href="https://webchat.freenode.net/?channels=elixir-lang">#elixir-lang</a></li>
                            <li><a href="https://groups.google.com/forum/#!forum/elixir-lang-talk">elixir-lang-talk</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Videos</h1>
                        <ul>
                            <li><a href="http://elixirsips.com">elixirsips.com</a></li>
                            <li><a href="http://infoq.com">InfoQ</a></li>
                            <li><a href="https://www.youtube.com/user/ErlangSolutions">Erlang Solutions on Youtube</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Books</h1>
                        <ul>
                            <li><a href="https://pragprog.com/book/elixir/programming-elixir">Programming Elixir</a></li>
                            <li><a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir">Metaprogramming Elixir</a></li>
                        </ul>
                    </section>
                    <section>
                        <h1>Websites</h1>
                        <ul>
                            <li><a href="http://elixir-lang.org">elixir-lang.org</a></li>
                            <li><a href="https://github.com/h4cc/awesome-elixir">Awesome Elixir</a></li>
                        </ul>
                    </section>
                </section>
            </div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

                width: 2048,
                height: 1280,


                // Slide number formatting can be configured using these variables:
                //  h: current slide's horizontal index
                //  v: current slide's vertical index
                //  c: current slide index (flattened)
                //  t: total number of slides (flattened)
                slideNumber: 'c / t',

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
